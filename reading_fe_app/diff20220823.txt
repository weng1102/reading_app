diff --git a/reading_fe_app/src/App.css b/reading_fe_app/src/App.css
index 07eacfd..7c7f37c 100644
--- a/reading_fe_app/src/App.css
+++ b/reading_fe_app/src/App.css
@@ -504,17 +504,35 @@ input[type="radio"]{
   width: 100%;
   max-width: 500px;
 }
-.image-entry-image-top-bootom {
+.image-entry-image-top-bottom {
   min-height: 300px;
   max-height: 300px;
 }
 .link-label {
-  text-decoration: underline ;
+  text-decoration: underline;
   color: blue;
 }
 .link-label1 {
   text-decoration: underline dotted;
 }
+.fillin-title {
+  font-weight:bold;
+}
+.fillin-responses-attributes {
+  font-style: italic;
+}
+.fillin-prompts-terminal {
+  display: inline-block; /* Be careful of unintended side effects  */
+  min-width:20px;
+  text-decoration: none;
+  text-align: center;
+  border-bottom: 1px dashed black;
+  padding-left: 10px;
+  padding-right: 10px;
+}
+.fillin-prompts-terminal-hidden {
+  color: rgba(0,0,0,0.0); /* transparent */
+}
 .textbox-control {
   height: auto;
   font-family: monospace;
diff --git a/reading_fe_app/src/pageContentType.ts b/reading_fe_app/src/pageContentType.ts
index 6f7641e..bd38f92 100644
--- a/reading_fe_app/src/pageContentType.ts
+++ b/reading_fe_app/src/pageContentType.ts
@@ -8,7 +8,7 @@
  *
  **/
 export const IDX_INITIALIZER = -9999;
-export const PageContentVersion = "20220407.1";
+export const PageContentVersion = "20220511.1";
 export enum PageFormatEnumType {
   default = 0
 }
@@ -33,6 +33,7 @@ export interface IPageContent {
   sectionList: ISectionListItem[];
   sentenceList: ISentenceListItem[];
   linkList: ILinkListItem[];
+  fillinList: ISectionFillinItem[];
 }
 export function PageContentInitializer(): IPageContent {
   return {
@@ -55,7 +56,8 @@ export function PageContentInitializer(): IPageContent {
     headingList: [],
     sectionList: [],
     sentenceList: [],
-    linkList: []
+    linkList: [],
+    fillinList: []
   };
 }
 export interface ISectionContent {
@@ -77,9 +79,9 @@ export type SectionVariantType =
   | ISectionParagraphVariant
   | ISectionFillinVariant
   | ISectionBlockquoteVariant
-  | ISectionFillinListVariant
   | ISectionImageEntryVariant
-  | ISectionButtonGridVariant;
+  | ISectionButtonGridVariant
+  | ISectionTbdVariant;
 
 export enum SectionVariantEnumType {
   heading = "heading",
@@ -91,7 +93,7 @@ export enum SectionVariantEnumType {
   fillin = "fillin",
   fillin_list = "fillin_list",
   image_entry = "image_entry",
-  button_grid = "buttongrip",
+  button_grid = "buttongrid",
   blockquote = "blockquote",
   unittest = "unittest",
   empty = "empty",
@@ -120,14 +122,6 @@ export enum UnorderedListMarkerEnumType { // standard HTML
   none,
   other
 }
-export interface ISectionFillinVariant {
-  minColumns: number; // minimum number of columns for fillin table
-}
-export function ISectionFillinVariantInitializer(): ISectionFillinVariant {
-  return {
-    minColumns: 0 // overrides name and description above
-  };
-}
 export interface ISectionHeadingVariant1 {
   title: string; // ISentenceContent where audible/recitable can be disabled at run time.
 
@@ -247,12 +241,43 @@ export function ISectionParagraphVariantInitializer(): ISectionParagraphVariant
     style: "" // overrides css but not user profile
   };
 }
-export interface ISectionFillinVariant {}
-export function ISectionFillinBariantInitializer() {}
-
-export interface ISectionFillinListVariant {}
-export function ISectionFillinListVariantInitializer() {}
-
+export enum SectionFillinFormatType {
+  list = "list",
+  grid = "grid"
+}
+export interface ISectionFillinVariant {
+  sectionFillinIdx: number; // reference state structure in pageList.fillinList
+  title: string; // title of entire fillin section
+  label: string; // label for response list/grid
+  format: SectionFillinFormatType; // list, grid
+  gridColumns: number; // 0 means no response table
+  groupDuplicates: boolean; // identical words groouped as single response entry
+  showCategoryHint: boolean; // shows (noun) beside hidden word
+  includeCategory: boolean; // shows (noun) in response list/grid
+  sortOrder: boolean; // sort alphabetically
+  allowReset: boolean; // reset button
+  prompts: ISectionContent[];
+}
+export function ISectionFillinVariantInitializer(
+  sectionFillinIdx: number = IDX_INITIALIZER,
+  title: string = "",
+  label = "Responses:",
+  format = SectionFillinFormatType.list
+): ISectionFillinVariant {
+  return {
+    sectionFillinIdx: sectionFillinIdx,
+    title: title,
+    label: label,
+    format: format,
+    gridColumns: 0,
+    groupDuplicates: true,
+    showCategoryHint: false,
+    includeCategory: false,
+    sortOrder: true,
+    allowReset: false,
+    prompts: []
+  };
+}
 export enum ImageEntryLayoutEnumType {
   left = "left", // default, image to the left of caption
   above = "above" // image above caption
@@ -265,7 +290,7 @@ export interface ISectionImageEntryVariant {
   images: ITerminalContent[]; // path to img/filenames
   captions: ISectionContent[];
 }
-export function ISectionImageEntryVariantInitializer() {
+export function ISectionImageEntryVariantInitializer(): ISectionImageEntryVariant {
   return {
     title: "",
     layout: ImageEntryLayoutEnumType.left,
@@ -278,7 +303,7 @@ export function ISectionImageEntryVariantInitializer() {
 export interface ISectionTbdVariant {
   context: string; // message in a bottle
 }
-export function ISectionTbdVariantInitializer() {
+export function ISectionTbdVariantInitializer(): ISectionTbdVariant {
   return {
     context: ""
   };
@@ -307,9 +332,11 @@ export enum TerminalMetaEnumType {
   currency,
   date,
   emailaddress,
+  fillin,
   image,
   link,
   numberwithcommas,
+  passthruTag,
   phonenumber,
   punctuation,
   symbol,
@@ -326,6 +353,7 @@ export interface ITerminalContent {
   firstTermIdx: number;
   lastTermIdx: number;
   content: string; // not necessary
+  cueList: string;
   type: TerminalMetaEnumType;
   meta: TerminalMetaType;
 }
@@ -336,6 +364,8 @@ export type TerminalMetaType =
   | IEmailAddressTerminalMeta
   | IImageTerminalMeta
   | ICurriculumLinkTerminalMeta
+  | IFillinTerminalMeta
+  | IPassthruTagTerminalMeta
   | IPhoneNumberTerminalMeta
   | IPunctuationTerminalMeta
   | IReferenceTerminalMeta
@@ -350,34 +380,42 @@ export interface ITerminalInfo {
   termIdx: number;
   nextTermIdx: number[];
   prevTermIdx: number[];
+  cues: string[];
   altpronunciation: string;
   altrecognition: string;
   recitable: boolean;
   audible: boolean;
   linkable: boolean;
   visible: boolean;
-  fillin: boolean;
   visited: boolean;
   linkIdx: number;
   hintsIdx: number;
+  responseIdx: number;
+  bold: boolean;
+  italics: boolean;
+  markupTag: boolean;
   //cues: string[] includes terminal type word, day, month, year, number, area code,...
 }
 export function ITerminalInfoInitializer(
   content: string = "",
   altpronunciation: string = "",
   altrecognition: string = "",
+  cues: string[] = [],
   recitable: boolean = true,
   audible: boolean = true,
   linkable: boolean = false,
   visible: boolean = true,
-  fillin: boolean = false,
   visited: boolean = false,
   linkIdx: number = IDX_INITIALIZER,
-  hintsIdx: number = IDX_INITIALIZER
-  //cues
+  hintsIdx: number = IDX_INITIALIZER,
+  responseIdx: number = IDX_INITIALIZER,
+  bold = false,
+  italics = false,
+  markupTag = false
 ): ITerminalInfo {
   return {
     content: (content === undefined ? "" : content)!,
+    cues: cues,
     termIdx: IDX_INITIALIZER,
     nextTermIdx: [],
     prevTermIdx: [],
@@ -393,10 +431,13 @@ export function ITerminalInfoInitializer(
     audible: audible,
     linkable: linkable,
     visible: visible,
-    fillin: fillin,
     visited: visited,
     linkIdx: linkIdx,
-    hintsIdx: hintsIdx
+    hintsIdx: hintsIdx,
+    responseIdx: responseIdx,
+    bold: bold,
+    italics: italics,
+    markupTag: markupTag
   };
 }
 export interface IAcronymTerminalMeta {
@@ -455,6 +496,7 @@ export function IDateTerminalMetaInitializer(): IDateTerminalMeta {
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       false, // not recitable
       false, // not audible
       undefined, // accept default linkable
@@ -466,6 +508,7 @@ export function IDateTerminalMetaInitializer(): IDateTerminalMeta {
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       false, // not recitable
       false, // not audible
       undefined, // accept default linkable
@@ -478,6 +521,7 @@ export function IDateTerminalMetaInitializer(): IDateTerminalMeta {
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       true, // recitable
       true, //audible
       undefined, // accept default linkable
@@ -489,6 +533,7 @@ export function IDateTerminalMetaInitializer(): IDateTerminalMeta {
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       false, // not recitable
       false, // not audible
       undefined, // accept default linkable
@@ -499,6 +544,30 @@ export function IDateTerminalMetaInitializer(): IDateTerminalMeta {
     year: IYearTerminalMetaInitializer() // e.g., {19,61}, {20,10}, {2000,1}
   };
 }
+export interface IFillinTerminalMeta {
+  terminals: ITerminalContent[];
+  sectionIdx: number;
+  //  responseIdx: number;
+}
+export function IFillinTerminalMetaInitializer(
+  terminals: ITerminalContent[] = [],
+  sectionIdx = IDX_INITIALIZER
+  //  responseIdx = IDX_INITIALIZER
+): IFillinTerminalMeta {
+  return {
+    terminals,
+    sectionIdx
+    //    responseIdx
+  };
+}
+export interface IPassthruTagTerminalMeta {
+  tag: string;
+}
+export function IPassthruTagTerminalMetaTerminalMetaInitializer(): IPassthruTagTerminalMeta {
+  return {
+    tag: ""
+  };
+}
 export interface IImageTerminalMeta {
   src: string;
   label: string;
@@ -567,6 +636,7 @@ export function IPhoneNumberTerminalMetaInitializer(): IPhoneNumberTerminalMeta
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       false, // not recitable
       false, // not audible
       undefined, // accept default linkable
@@ -579,6 +649,7 @@ export function IPhoneNumberTerminalMetaInitializer(): IPhoneNumberTerminalMeta
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       false, // not recitable
       false, // not audible
       undefined, // accept default linkable
@@ -590,6 +661,7 @@ export function IPhoneNumberTerminalMetaInitializer(): IPhoneNumberTerminalMeta
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       false, // not recitable
       false, // not audible
       undefined, // accept default linkable
@@ -602,6 +674,7 @@ export function IPhoneNumberTerminalMetaInitializer(): IPhoneNumberTerminalMeta
       undefined, // accept default content
       undefined, // accept default altpro
       undefined, // accept default altreg
+      undefined, // accept default cues
       false, // not recitable
       false, // not audible
       undefined, // accept default linkable
@@ -620,6 +693,7 @@ export function IPunctuationTerminalMetaInitializer(
     content,
     undefined, // accept default altpro
     undefined, // accept default altreg
+    undefined, // accept default cues
     false, // not recitable
     false, // not audible
     undefined, // accept default linkable
@@ -645,6 +719,7 @@ export function IWhitespaceTerminalMetaInitializer(
     content,
     undefined, // accept default altpro
     undefined, // accept default altreg
+    undefined, // accept default cues
     false, // not recitable
     false, // not audible
     undefined, // accept default linkable
@@ -780,3 +855,54 @@ export function ILinkListItemInitializer(
 ): ILinkListItem {
   return { label, destination, valid };
 }
+// export interface IFillinItem {
+//   content: string; // for display in response list
+//   referenceCount: number;
+// }
+export interface IFillinResponseItem {
+  content: string; // for display in response list
+  referenceCount: number;
+}
+export interface IFillinPromptItem {
+  // list of all terminalInfos in prompt
+  visible: boolean;
+  responseIdx: number; // index into section response context
+}
+export interface ISectionFillinItem {
+  groupDuplicates: boolean;
+  sortOrder: boolean; // sort alphabetically
+  responses: IFillinResponseItem[]; // index into section response context
+  //  prompts: IFillinPromptItem[]; // list of all terminalInfos in prompt
+  loaded: boolean;
+}
+export function ISectionFillinItemInitializer(
+  groupDuplicates: boolean = true,
+  sortOrder: boolean = true, // sort alphabetically
+  responses: IFillinResponseItem[] = [],
+  //  prompts: IFillinPromptItem[] = [],
+  loaded: boolean = false
+): ISectionFillinItem {
+  return {
+    groupDuplicates,
+    sortOrder,
+    responses,
+    //    prompts,
+    loaded
+  };
+}
+// export interface ISectionFillinList {
+//   groupDuplicates: boolean;
+//   sortOrder: boolean; // sort alphabetically
+//   fillinList: IFillinItem[];
+// }
+// export function ISectionFillinListInitializer(
+//   groupDuplicates: boolean = true,
+//   sortOrder: boolean = true, // sort alphabetically
+//   fillinList: IFillinItem[] = []
+// ): ISectionFillinList {
+//   return {
+//     groupDuplicates,
+//     sortOrder,
+//     fillinList
+//   };
+// }
diff --git a/reading_fe_app/src/pageContext.ts b/reading_fe_app/src/pageContext.ts
index d092f64..aec2935 100644
--- a/reading_fe_app/src/pageContext.ts
+++ b/reading_fe_app/src/pageContext.ts
@@ -17,7 +17,8 @@ import {
   ILinkListItem,
   ISentenceListItem,
   ISectionListItem,
-  ITerminalListItem
+  ITerminalListItem,
+  ISectionFillinItem
 } from "./pageContentType";
 
 // export interface IPageContext1 {
@@ -36,20 +37,23 @@ export interface IPageLists {
   sectionList: ISectionListItem[];
   sentenceList: ISentenceListItem[];
   linkList: ILinkListItem[];
+  fillinList: ISectionFillinItem[];
 }
 export function PageListsInitializer(
   terminalList: ITerminalListItem[] = [],
   headingList: IHeadingListItem[] = [],
   sectionList: ISectionListItem[] = [],
   sentenceList: ISentenceListItem[] = [],
-  linkList: ILinkListItem[] = []
+  linkList: ILinkListItem[] = [],
+  fillinList: ISectionFillinItem[] = []
 ): IPageLists {
   return {
     terminalList: terminalList,
     headingList: headingList,
     sectionList: sectionList,
     sentenceList: sentenceList,
-    linkList: linkList
+    linkList: linkList,
+    fillinList: fillinList
   };
 }
 // export const PageContext = React.createContext(null as IPageContext | null);
@@ -75,19 +79,22 @@ export class CPageLists {
     headingList: IHeadingListItem[] = [],
     sectionList: ISectionListItem[] = [],
     sentenceList: ISentenceListItem[] = [],
-    linkList: ILinkListItem[] = []
+    linkList: ILinkListItem[] = [],
+    fillinList: ISectionFillinItem[] = []
   ) {
     this.terminalList = terminalList;
     this.headingList = headingList;
     this.sectionList = sectionList;
     this.sentenceList = sentenceList;
     this.linkList = linkList;
+    this.fillinList = fillinList;
   }
   terminalList: ITerminalListItem[];
   headingList: IHeadingListItem[];
   sectionList: ISectionListItem[];
   sentenceList: ISentenceListItem[];
   linkList: ILinkListItem[];
+  fillinList: ISectionFillinItem[];
 
   get firstTerminalIdx(): number {
     return 0;
diff --git a/reading_fe_app/src/reactcomp_listen.tsx b/reading_fe_app/src/reactcomp_listen.tsx
index f9423f0..bd09821 100644
--- a/reading_fe_app/src/reactcomp_listen.tsx
+++ b/reading_fe_app/src/reactcomp_listen.tsx
@@ -9,6 +9,7 @@
  *
  **/
 import "./App.css";
+import { CPageLists, PageContext } from "./pageContext";
 import listenRedActiveIcon from "./img/button_listen_activeRed.gif";
 import listenIcon from "./img/button_listen.png";
 import listenGhostedIcon from "./img/button_listen_ghosted.png";
@@ -27,25 +28,33 @@ import {
 
 export const ListeningMonitor = () => {
   //console.log = function() {}; // disable console logging
-  const [wordsPreviouslyHeard, setWordsPreviouslyHeard] = useState("");
+  const [wordsHeardPreviously, setWordsHeardPreviously] = useState("");
+  const [wordPosition, setWordPosition] = useState(-1);
+  const [wordPositionPreviously, setWordPositionPreviously] = useState(-1);
+  const [wordRetries, setWordRetries] = useState(0);
+  const resetListeningState = () => {
+    setWordPositionPreviously(-1);
+    setWordPosition(-1);
+    setWordsHeardPreviously("");
+    setWordRetries(0);
+  };
   const dispatch = useAppDispatch();
+
   const listeningRequested: boolean = useAppSelector(
     store => store.listen_active
   );
+  const pageContext: CPageLists = useContext(PageContext)!;
 
   let settingsContext: ISettingsContext = useContext(
     SettingsContext
   ) as ISettingsContext;
+  const maxRetries: number = settingsContext.settings.listen.retries;
   const silenceTimeout: number = settingsContext.settings.listen.timeout;
-  // let queuingDuration: number =
-  //   settingsContext.settings.listen.listeningInterval;
-  const retries: number = useAppSelector(store => store.listen_retries);
-
   interface IRecognitionArguments {
     continuous: boolean;
     language: string;
   }
-  const ContinuousListeningForEnglish: IRecognitionArguments = {
+  const ContinuousListeningInEnglish: IRecognitionArguments = {
     continuous: true,
     language: "en-US"
   };
@@ -58,7 +67,7 @@ export const ListeningMonitor = () => {
   const startSilenceTimer = (): ReturnType<typeof setTimeout> => {
     if (silenceTimerId !== undefined) {
       clearTimeout(silenceTimerId);
-      console.log(`clearing previous silence timer for id=${silenceTimerId}`);
+      // console.log(`clearing previous silence timer for id=${silenceTimerId}`);
     }
     let retval = setTimeout(() => {
       console.log(`SILENCE TIMEOUT TRIGGERED`);
@@ -67,13 +76,13 @@ export const ListeningMonitor = () => {
       SpeechRecognition.abortListening();
       dispatch(Request.Recognition_stop());
     }, silenceTimeout * 1000);
-    console.log(`Starting silence timer for id=${retval}`);
+    // console.log(`Starting silence timer for id=${retval}`);
     setSilenceTimerId(retval);
     return retval;
   };
   const clearSilenceTimer = () => {
     if (silenceTimerIdRef.current !== undefined) {
-      console.log(`clearing silence timer id=${silenceTimerIdRef.current}`);
+      // console.log(`clearing silence timer id=${silenceTimerIdRef.current}`);
       clearTimeout(silenceTimerIdRef.current);
     }
   };
@@ -84,14 +93,13 @@ export const ListeningMonitor = () => {
     resetTranscript,
     listening
   } = useSpeechRecognition();
-
   ////////////////////////////////////
   // Start and stop listening manually
   ////////////////////////////////////
   useEffect(() => {
     if (!listening && listeningRequested) {
       console.log(`restart listening because browser eventually times out`);
-      SpeechRecognition.startListening(ContinuousListeningForEnglish);
+      SpeechRecognition.startListening(ContinuousListeningInEnglish);
     }
   }, [listening, listeningRequested]);
   useEffect(() => {
@@ -102,7 +110,7 @@ export const ListeningMonitor = () => {
       console.log("LISTENING: stop listening requested");
     } else {
       // timeout periodically not
-      SpeechRecognition.startListening(ContinuousListeningForEnglish);
+      SpeechRecognition.startListening(ContinuousListeningInEnglish);
 
       console.log(`LISTENING: start listening with timeout=${silenceTimeout}s`);
       startSilenceTimer();
@@ -111,54 +119,107 @@ export const ListeningMonitor = () => {
       );
     }
   }, [listeningRequested]);
-
+  const expectedTerminalIdx: number = useAppSelector(
+    store => store.cursor_terminalIdx
+  );
   useEffect(() => {
-    let words: string;
+    let wordsHeard: string;
+    let finalTranscriptEncountered: boolean = false;
     if (!listening) {
       // console.log(`LISTENING: No longer listening...`);
       if (listeningRequested) {
         // speech recognition timed out
         // console.log(`NO LONGER LISTENING...BUT LISTENING RESTARTED`);
-        SpeechRecognition.startListening(ContinuousListeningForEnglish); // timeout periodically not
+        SpeechRecognition.startListening(ContinuousListeningInEnglish); // timeout periodically not
       }
     } else {
-      // console.log(`LISTENING...`);
     }
-    {
+    if (listening) {
       if (finalTranscript !== "") {
-        console.log(`final=  ${finalTranscript}`);
-        words = finalTranscript;
+        finalTranscriptEncountered = true;
+        wordsHeard = finalTranscript;
         resetTranscript();
       } else {
-        words = interimTranscript;
+        wordsHeard = interimTranscript;
         console.log(`interim=${interimTranscript}`);
       }
-      console.log(`heard=  ${words}`);
-      // words === wordsPreviouslyHeard) {
-      // need to skip matching if nothing new is recognized. Remember, the
-      // SpeechRecognition engine continues to guess at what was said even
-      // though the speaker hasn't uttered another word. This check is
-      // primarily to try and reduce inadvertant retry increment...
-      // but its not very effective because the engine typically returns
-      // different interpretations of what it heard.
-      // Also, previously heard words should only be compared to words NOT
-      // silence (blanks)
-      if (words.length === 0) {
-        console.log(`detecting silence`);
-      } else if (wordsPreviouslyHeard.includes(words)) {
-        console.log(`detecting only previous words`);
+      console.log(`LISTENING: Heard=  ${wordsHeard}`);
+      if (wordsHeard.length === 0) {
+        resetListeningState();
+        // setWordPosition(-1);
+        // setWordsHeardPreviously("");
+        // setWordPositionPreviously(-1);
+        console.log(
+          `LISTENING: Detecting silence wordPos=${wordPosition} wordPosPrev=${wordPositionPreviously}`
+        );
+        // } else if (wordsPreviouslyHeard === wordsHeard) {
+        //   console.log(`detecting only previous words`);
+      } else if (
+        wordsHeardPreviously.includes(wordsHeard) &&
+        wordPosition === wordPositionPreviously
+      ) {
+        // same word i.e., same word within same words heard list
+        console.log(
+          `LISTENING: Detecting only previous words: "${wordsHeardPreviously}" wordPos=${wordPosition} wordPosPrev=${wordPositionPreviously}`
+        );
       } else {
-        //        setWordsPreviouslyHeard(words);
+        console.log(`LISTENING: Parsing words="${wordsHeard}"`);
+        let wordsHeardList = wordsHeard.split(" ");
+        let matchMessage: string;
+        setWordsHeardPreviously(wordsHeard);
+        setWordPositionPreviously(-1);
         startSilenceTimer();
-        dispatch(Request.Cursor_matchWords(words));
-
-        // in the future, the actual word matching can be brought into this
-        // component and just sent dispatch Cursor_gotoNextWord() and
-        // retriesExceeded.
-        // clean up timer to prevent weird behavior and memory leaks
+        let expecting: string = pageContext.terminalList[
+          expectedTerminalIdx
+        ].content.toLowerCase();
+        let expectingAlt: string = pageContext.terminalList[
+          expectedTerminalIdx
+        ].altrecognition.toLowerCase();
+        let wordPos: number;
+        let wordHeard: string;
+        setWordPositionPreviously(wordPosition);
+        for (
+          wordPos = wordPosition + 1;
+          wordPos < wordsHeardList.length;
+          wordPos++
+        ) {
+          console.log(
+            `LISTENING: Looping wordPos=${wordPos}  wordPosPrev=${wordPositionPreviously}`
+          );
+          wordHeard = wordsHeardList[wordPos].toLowerCase();
+          if (expecting === wordHeard) {
+            setWordPosition(wordPos);
+            setWordRetries(0);
+            matchMessage = `LISTENING: Matched "${expecting}" with ${wordHeard} wordPos=${wordPos} wordPosPrev=${wordPositionPreviously}`;
+            dispatch(Request.Recognition_match(matchMessage));
+            break;
+          } else if (expectingAlt === wordHeard) {
+            setWordPosition(wordPos);
+            setWordRetries(0);
+            matchMessage = `LISTENING: Matched alternative with "${expectingAlt} wordPos=${wordPos} wordPosPrev=${wordPositionPreviously} idx=${expectedTerminalIdx}`;
+            dispatch(Request.Recognition_match(matchMessage));
+            break;
+          } else if (
+            expectingAlt.length > 0 &&
+            patternMatch(wordHeard, expectingAlt)
+          ) {
+            setWordPosition(wordPos);
+            setWordRetries(0);
+            matchMessage = `LISTENING: Matched pattern with "${expectingAlt} wordPos=${wordPos}  wordPosPrev=${wordPositionPreviously} idx=${expectedTerminalIdx}`;
+            dispatch(Request.Recognition_match(matchMessage));
+            break;
+          } else {
+            matchMessage = `LISTENING: Retrying "${expecting}" or  "${expectingAlt}" but hearing word "${wordHeard}" within clause "${wordsHeard}" wordPos=${wordPos}  wordPosPrev=${wordPositionPreviously} with ${wordRetries} retries.`;
+            setWordRetries(wordRetries + 1);
+          }
+        }
+      }
+      if (finalTranscriptEncountered) {
+        resetListeningState();
       }
     }
     return () => {
+      // console.log(`LISTENING: Clearing timer`);
       clearTimeout(silenceTimerIdRef.current!);
     };
   }, [
@@ -167,32 +228,37 @@ export const ListeningMonitor = () => {
     transcript,
     interimTranscript,
     finalTranscript,
-    resetTranscript
+    resetTranscript,
+    expectedTerminalIdx
   ]);
-  const retriesExceeded = useAppSelector(store => store.listen_retriesExceeded);
+  // const retriesExceeded = useAppSelector(store => store.listen_retriesExceeded);
   const reciteWordRequested = useAppSelector(
     store => store.recite_word_requested
   );
   useEffect(() => {
-    console.log(`LISTENING: retries exceeded; reset transcript`);
-    if (retriesExceeded) {
+    // console.log(`LISTENING: retries`);
+    if (wordRetries > maxRetries) {
+      // console.log(`LISTENING: retries exceeded; reset transcript`);
       if (!reciteWordRequested) {
+        // console.log(`LISTENING: retries exceeded; recite not requested`);
         resetTranscript();
         dispatch(Request.Recite_currentWord());
       } else {
-        dispatch(Request.Cursor_gotoNextWord());
+        // console.log(`LISTENING: retries exceeded; goto next word`);
+        dispatch(Request.Cursor_gotoNextWord("retries exceeded"));
+        setWordRetries(0);
       }
     }
-  }, [retriesExceeded, reciteWordRequested]);
-  const flushRequested: boolean = useAppSelector(store => store.listen_flush);
-  useEffect(() => {
-    if (flushRequested) {
-      console.log(`LISTENING: flushing transcript queue`);
-      resetTranscript();
-      dispatch(Request.Recognition_flushed());
-    } else {
-    }
-  }, [flushRequested]);
+  }, [wordRetries, reciteWordRequested]);
+  // const flushRequested: boolean = useAppSelector(store => store.listen_flush);
+  // useEffect(() => {
+  //   if (flushRequested) {
+  //     console.log(`LISTENING: flushing transcript queue`);
+  //     resetTranscript();
+  //     dispatch(Request.Recognition_flushed());
+  //   } else {
+  //   }
+  // }, [flushRequested]);
 
   ///////////////////////
   // Transition callbacks
@@ -203,7 +269,9 @@ export const ListeningMonitor = () => {
   useEffect(() => {
     if (newSentence) {
       console.log(`LISTENING: new sentence transition`);
-      dispatch(Request.Recognition_flush());
+      //      dispatch(Request.Recognition_flush());
+      resetListeningState();
+      resetTranscript();
     }
   }, [newSentence]);
   const message_listen: string = useAppSelector(
@@ -532,3 +600,7 @@ export const NotificationModeRadioButton = (
     </>
   );
 };
+function patternMatch(content: string, altRecognitionPattern: string): boolean {
+  let pattern: RegExp = new RegExp(altRecognitionPattern);
+  return pattern.test(content);
+}
diff --git a/reading_fe_app/src/reactcomp_main.tsx b/reading_fe_app/src/reactcomp_main.tsx
index 4717701..f369d30 100644
--- a/reading_fe_app/src/reactcomp_main.tsx
+++ b/reading_fe_app/src/reactcomp_main.tsx
@@ -25,7 +25,7 @@ export const ReadingApp = () => {
     settings: _settings,
     saveSettings: _setSettings
   };
-  // const restorePageRequested = useAppSelector(
+  // const restoreRequested = useAppSelector(
   //   store => store.page_restore_requested
   // );
   let dispatch = useAppDispatch();
@@ -37,7 +37,7 @@ export const ReadingApp = () => {
   if (_settings.config.homePage.length === 0) {
     dispatch(Request.Page_load("sitemap"));
   } else {
-    // } else if (!restorePageRequested) {
+    // } else if (!restoreRequested) {
     dispatch(Request.Page_home());
   }
   return (
diff --git a/reading_fe_app/src/reactcomp_page.tsx b/reading_fe_app/src/reactcomp_page.tsx
index 0503636..88db30f 100644
--- a/reading_fe_app/src/reactcomp_page.tsx
+++ b/reading_fe_app/src/reactcomp_page.tsx
@@ -24,8 +24,8 @@
  *    subsequently assigned within the reducer for eventual consumption by
  *    react component(s).
  *
- * Even though reducer state tracks both the pageRequested and pageContext
- * changes, internal component state variable isPageLoaded tracks when new
+ * Even though reducer state tracks both the Requested and pageContext
+ * changes, internal component state variable canRender tracks when new
  * load is requested but not yet properly loaded.
  *
  * The context and content are not loaded until successful to prevent the
@@ -51,13 +51,14 @@ import { PageHeader } from "./reactcomp_pageheader";
 import { PageFooter } from "./reactcomp_pagefooter";
 import { SettingsDialog } from "./reactcomp_settings";
 import { SectionDispatcher } from "./reactcomp_sections";
+// import { FillinSectionContexts, IFillinSectionContexts } from "./fillinContexts";
+
 // import { StatusBarMessageType } from "./reducers";
 
 interface IPreviousPageArrayItem {
   page: string;
   currentTermIdx: number;
 }
-
 export interface IPagePropsType {
   appName: string;
 }
@@ -66,12 +67,12 @@ export const Page = React.memo((props: IPagePropsType) => {
   const [parseError, setParseError] = useState<string | null>(null);
   const [pageContent, setPageContent] = useState<IPageContent | null>(null);
   const [pageContext, setPageContext] = useState<CPageLists | null>(null);
-  const [isPageLoaded, setIsPageLoaded] = useState<boolean>(true);
+  const [canRender, setCanRender] = useState<boolean>(true);
   const [previousPages, setPreviousPages] = useState<IPreviousPageArrayItem[]>(
     []
   );
   // Strictly current saves page state between page request and successful page
-  // load so this current page can be  pushed on PreviousPages stack iff next page loads successfully.
+  // load so this current page can be pushed onto PreviousPages stack iff next page loads successfully.
   const [currentPage, setCurrentPage] = useState<string>("");
   const [currentIdx, setCurrentIdx] = useState<number>(0);
   const { isActive, toggleDialog } = useDialog();
@@ -96,36 +97,45 @@ export const Page = React.memo((props: IPagePropsType) => {
       .then(
         data => {
           try {
-            setPageContent(data as IPageContent);
-            message = `Changing page context for "${pageRequested}"`;
-            if (pageContent !== undefined && pageContent !== null) {
-              if (data.version !== PageContentVersion) {
-                setParseError(
-                  `version mismatch. Expected ${PageContentVersion} but encountered ${data.version} in content`
-                );
-              } else {
-                let pageContext: CPageLists = new CPageLists(
-                  pageContent.terminalList,
-                  pageContent.headingList,
-                  pageContent.sectionList,
-                  pageContent.sentenceList,
-                  pageContent.linkList
-                );
-                if (pageContext !== null) {
-                  message = `Loaded page context for "${pageRequested}"`;
-                  setPageContext(pageContext);
-                  dispatch(Request.Page_setContext(pageContext));
-                  dumpPreviousPageStack("beforePageLoaded");
-                  setIsPageLoaded(true);
-                  dumpPreviousPageStack("afterPageLoaded");
-                  //                setCurrentPage(pageRequested);
-                  //                dispatch(Request.Page_loaded(true));
-                } else {
-                  message = `Loading page context failed for "${pageRequested}"`;
-                }
-                //              dispatch(Request.StatusBar_Message_set(message));
-              }
-            }
+            if (data.version !== PageContentVersion) {
+              setParseError(
+                `version mismatch. Expected ${PageContentVersion} but encountered ${data.version} in content`
+              );
+            } else {
+              let content: IPageContent = data as IPageContent;
+              message = `Changing page context for "${pageRequested}"`;
+              setPageContext(null);
+              let pageLists: CPageLists = new CPageLists(
+                content.terminalList,
+                content.headingList,
+                content.sectionList,
+                content.sentenceList,
+                content.linkList,
+                content.fillinList
+              );
+              message = `Loaded page context for "${pageRequested}"`;
+              // console.log(`settingSectionFillin`);
+              // // loop through fillinList
+              // FillinSectionContexts = new IFillinSectionContexts[content.fillinList.length]
+              // for (const fillin of content.fillinList) {
+              //   ISectionFillinItem\
+              //
+              // }
+
+              console.log(`settingPageContent`);
+              setPageContent(content);
+              console.log(`setPageContent`);
+              console.log(`settingPageContext`);
+              setPageContext(pageLists);
+              console.log(`setPageContext`);
+              dispatch(Request.Page_setContext(pageLists));
+              // dumpPreviousPageStack("beforePageLoaded");
+              setCanRender(true);
+              // dumpPreviousPageStack("afterPageLoaded");
+              //                setCurrentPage(pageRequested);
+              //                dispatch(Request.Page_loaded(true));
+              message = `Loading page context failed for "${pageRequested}"`;
+            } // version check
           } catch (e) {
             let message: string = (e as Error).message;
             message = `Encountered unexpected fetching error: ${message}`;
@@ -133,19 +143,30 @@ export const Page = React.memo((props: IPagePropsType) => {
           }
         },
         error => {
-          setParseError(error);
+          // some other parseError
+          if (parseError === null) setParseError(error);
         }
       );
   };
-  let dispatch = useAppDispatch();
   const settingsContext: ISettingsContext = useContext(SettingsContext)!;
   const distDir: string = settingsContext.settings.config.distDir;
-  const homePage: string = settingsContext.settings.config.homePage;
+  const homePage: string = `homepage_${settingsContext.settings.config.homePage}`;
   const pageLoaded: boolean = useAppSelector(store => store.page_loaded);
-  let message: string = "";
+  const pageRequested: string = useAppSelector(store => store.page_requested);
+  const pageRestoreRequested: boolean = useAppSelector(
+    store => store.page_restore_requested
+  );
+  const pageHomeRequested: boolean = useAppSelector(
+    store => store.page_home_requested
+  );
   const currentTermIdx: number = useAppSelector(
     store => store.cursor_terminalIdx
   );
+  const pagePopRequested: boolean = useAppSelector(
+    store => store.page_pop_requested
+  );
+  let dispatch = useAppDispatch();
+  let message: string = "";
   const dumpPreviousPageStack = (message: string) => {
     //  return; //disable dumpPreviousPageStack
     let elString: string = "";
@@ -155,16 +176,12 @@ export const Page = React.memo((props: IPagePropsType) => {
     elString = elString.length > 0 ? elString : "(empty)";
     console.log(`${message}: previousPage Stack ${elString} `);
   };
-  const pageRequested: string = useAppSelector(store => store.page_requested);
-  const pageRestoreRequested: boolean = useAppSelector(
-    store => store.page_restore_requested
-  );
   useEffect(() => {
     // Initiates page load requested but not yet loaded
     if (
       !pageLoaded &&
-      currentPage.length > 0 &&
-      currentPage !== pageRequested
+      currentPage.length > 0
+      //&& currentPage !== pageRequested // not a reload
     ) {
       previousPages.push({
         page: currentPage,
@@ -172,58 +189,57 @@ export const Page = React.memo((props: IPagePropsType) => {
       });
     }
     if (previousPages.length > 0) {
-      dispatch(Request.Page_homeEnabled(true));
-      dispatch(Request.Page_previousEnabled(true));
+      dispatch(Request.Page_homeEnabled(true)); // unghost icon
+      dispatch(Request.Page_previousEnabled(true)); // unghost icon
     }
-    dumpPreviousPageStack("initial page request");
-    setIsPageLoaded(
+    // dumpPreviousPageStack("initial page request");
+    setCanRender(
       !(pageRequested !== undefined && pageRequested !== null && !pageLoaded)
     );
 
-    fetchRequest(distDir + pageRequested + ".json");
-  }, [distDir, pageRequested, pageLoaded, pageRestoreRequested]);
+    // if (pageRequested.length > 0) {
+    //   setPageContext(null);
+    //   fetchRequest(distDir + pageRequested + ".json");
+    // }
+  }, [pageRequested, pageLoaded, pageRestoreRequested, currentPage]);
 
   useEffect(() => {
     // requested page loading complete
-    if (!isPageLoaded) {
+    if (!canRender) {
       dispatch(Request.Page_loaded(true));
-      setIsPageLoaded(true);
+      //      setCanRender(true);
       //      setPreviousPages(previousPages);
       setCurrentPage(pageRequested);
-      dumpPreviousPageStack("!isPageLoaded");
+      // dumpPreviousPageStack("!canRender");
 
       // if requested page is home page then clear stack!
     } else {
       // save previous page requested after page loaded for push later
       setCurrentPage(pageRequested);
     }
-  }, [pageContent]);
+  }, [canRender]);
 
   useEffect(() => {
     if (pageRequested === currentPage) setCurrentIdx(currentTermIdx);
   }, [pageRequested, currentPage, currentTermIdx]);
 
-  const pageHomeRequested: boolean = useAppSelector(
-    store => store.page_home_requested
-  );
   useEffect(() => {
     if (pageHomeRequested) {
       console.log(`home requested`);
       setPreviousPages([]);
       setCurrentPage("");
       setCurrentIdx(0);
-      dispatch(Request.Page_load(`homepage_${homePage}`));
+      dispatch(Request.Page_load(homePage));
+      dispatch(Request.Page_homeEnabled(false));
       dispatch(Request.Page_homed());
     }
   }, [pageHomeRequested, homePage]);
 
-  const pagePopRequested: boolean = useAppSelector(
-    store => store.page_pop_requested
-  );
   useEffect(() => {
     // pop requested
     if (pagePopRequested) {
       console.log(`pop requested`);
+      previousPages.pop()!;
       let previousPage: IPreviousPageArrayItem = previousPages.pop()!;
       if (previousPage !== undefined) {
         console.log(
@@ -231,14 +247,14 @@ export const Page = React.memo((props: IPagePropsType) => {
         );
         setCurrentPage("");
         setCurrentIdx(0);
-        dumpPreviousPageStack("pagePopRequested");
+        // dumpPreviousPageStack("pagePopRequested");
         dispatch(
           Request.Page_load(previousPage.page, 0, previousPage.currentTermIdx)
         );
       } else {
         console.log(`previous page stack empty`);
       }
-      if (previousPages.length === 0) {
+      if (previousPages.length === 0 || previousPage.page === homePage) {
         dispatch(Request.Page_previousEnabled(false));
         dispatch(Request.Page_homeEnabled(false));
       }
@@ -257,30 +273,55 @@ export const Page = React.memo((props: IPagePropsType) => {
     }
   }, [pageRestoreRequested]);
 
-  if (pageLoaded) {
+  //////////
+  // pageHomeRequested pagePopRequested pageRestoreRequested should be
+  // translated into page_requested and
+  // should all be processes in render code and not useEffect() to avoid
+  // undesirable/unpredictable side effects
+  //////////
+
+  // Translate possible actions into page load
+  //iff canRender === false
+
+  //PAGE REQUESTS
+  //PAGE LOAD
+  //   if (pageRequested === currentPage) {
+  //     console.log(`no direct page requested`);
+  //     dispatch(Request.Page_loaded(true)); // cancel loading
+  // } else {  //PAGE LOAD
+  //     console.log(`page load requested ${pageRequested}`);
+  // }
+
+  if (!pageLoaded) {
+    // page requested already
     message = `Loaded page "${pageRequested}.json"`;
-    if (pageRequested !== currentPage) setCurrentPage(pageRequested);
-    dumpPreviousPageStack("pageLoaded");
-  } else if (responseError) {
-    message = `Encountered response error while loading "${pageRequested}.json": ${responseError}`;
-  } else if (parseError) {
-    const syntaxError: string =
-      "SyntaxError: Unexpected token < in JSON at position 0";
-    if (syntaxError.indexOf(parseError) === 0) {
-      message = `Encountered incompatible JSON format while loading for "${pageRequested}"`;
+    if (pageRequested.length === 0) {
+    } else if (pageRequested !== currentPage) {
+      message = `loading new page "${pageRequested} over current ${currentPage}"`;
+
+      fetchRequest(distDir + pageRequested + ".json");
+      setCurrentPage(pageRequested); // should be in useEffect() pageloaded
     } else {
-      message = `Encountered parsing error while loading "${pageRequested}.json": ${parseError}`;
+      message = `loading new page "${pageRequested} over current ${currentPage}"`;
     }
+    // dumpPreviousPageStack("pageLoaded");
+  } else if (parseError) {
+    message = parseError;
+  } else if (responseError) {
+    message = `Encountered response error while loading "${pageRequested}.json": ${responseError}`;
+  } else if (pageRequested.length === 0) {
+    message = `Waiting...unknown page requested`;
   } else {
-    message = `Waiting for page to load for "${pageRequested}"`;
+    message = `Waiting for page to load for "${pageRequested}..."`;
   }
   console.log(message);
   // React is complaining
   // need to wait until after <StatusBar is rendered OR  use
   // another means to detect that <StatusBar/> is loaded besides
   // surrogate pageContext
-
   if (pageContext !== null) {
+    /////// should be pageRenderable
+    console.log(`rendering page1`);
     return (
       <PageContext.Provider value={pageContext}>
         <div className="page">
@@ -293,6 +334,7 @@ export const Page = React.memo((props: IPagePropsType) => {
       </PageContext.Provider>
     );
   } else {
+    console.log(`rendering page2`);
     return <div className="loadingAnnouncement">{message}</div>;
   }
 });
diff --git a/reading_fe_app/src/reactcomp_sections.tsx b/reading_fe_app/src/reactcomp_sections.tsx
index 3626fa5..d2fe301 100644
--- a/reading_fe_app/src/reactcomp_sections.tsx
+++ b/reading_fe_app/src/reactcomp_sections.tsx
@@ -19,7 +19,7 @@ import {
   ISectionParagraphVariant
 } from "./pageContentType";
 import { Section_imageEntry } from "./reactcomp_sections_imageEntry";
-//import { Settings } from "./reactcomp_settings";
+import { Section_fillin } from "./reactcomp_section_fillin";
 import { Sentence } from "./reactcomp_sentences";
 
 export interface ISectionPropsType {
@@ -54,7 +54,8 @@ export const SectionDispatcher = React.memo((props: ISectionPropsType) => {
       // need to group because component will recursively render zero or more of each
       return <Section_Lists active={props.active} section={props.section} />;
     case SectionVariantEnumType.fillin:
-    case SectionVariantEnumType.fillin_list:
+      return <Section_fillin active={props.active} section={props.section} />;
+    //      return <div>section fillin response</div>;
     case SectionVariantEnumType.image_entry:
       return (
         <Section_imageEntry active={props.active} section={props.section} />
diff --git a/reading_fe_app/src/reactcomp_sections_imageEntry.tsx b/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
index 9b6c7bd..63b1fdb 100644
--- a/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
+++ b/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
@@ -44,11 +44,13 @@ export const Section_imageEntry = React.memo(
     let captions = imageEntry.captions as ISectionContent[];
     let className: string =
       imageEntry.layout.charAt(0).toLowerCase() === "l"
-        ? "imageentry-container-" + ImageEntryLayoutEnumType.left.toString()
-        : "imageentry-container-" + ImageEntryLayoutEnumType.above.toString();
-    let vdividerClassName = className + "-vdivider";
-    let hdividerClassName = className + "-hdivider";
+        ? `imageentry-container-${ImageEntryLayoutEnumType.left.toString()}`
+        : `imageentry-container-${ImageEntryLayoutEnumType.above.toString()}`;
+    let vdividerClassName = `${className}-vdivider`;
+    let hdividerClassName = `${className}-hdivider width=${imageEntry.percent}`;
     console.log(`imageEntry.percent ${imageEntry.percent}`);
+    // set width by changing --imageentry-min-image-width
+    // document.documentElement.style.setProperty()
     return (
       <>
         <div className={hdividerClassName}></div>
diff --git a/reading_fe_app/src/reactcomp_settings.tsx b/reading_fe_app/src/reactcomp_settings.tsx
index 7320f34..0f95cc6 100644
--- a/reading_fe_app/src/reactcomp_settings.tsx
+++ b/reading_fe_app/src/reactcomp_settings.tsx
@@ -110,7 +110,7 @@ export const SettingsDialog = (props: ISettingsDialogPropsType) => {
     setModified(false);
     // setNewSettings(SettingsCloner(settingsContext));
     props.hide();
-    dispatch(Request.Test_set());
+    //    dispatch(Request.Test_set());
   };
   let OkIcons = modified ? OkIcon : OkIcon_ghosted;
   let dispatch = useAppDispatch();
diff --git a/reading_fe_app/src/reactcomp_terminals.tsx b/reading_fe_app/src/reactcomp_terminals.tsx
index fac87c0..1c52ca9 100644
--- a/reading_fe_app/src/reactcomp_terminals.tsx
+++ b/reading_fe_app/src/reactcomp_terminals.tsx
@@ -16,7 +16,7 @@
 import React from "react";
 import { Request } from "./reducers";
 import { useAppDispatch, useAppSelector, useSpanRef } from "./hooks";
-import { useEffect } from "react";
+import { useContext, useEffect } from "react";
 
 // is this really necessary if availablility is removed below
 import {
@@ -25,12 +25,14 @@ import {
   IAcronymTerminalMeta,
   TerminalMetaEnumType
 } from "./pageContentType";
+import { TerminalFillinContext } from "./fillinContext";
 
 import { Terminal_Date } from "./reactcomp_terminals_dates";
 import { Terminal_Emailaddress } from "./reactcomp_terminals_emailaddress";
 import { Terminal_PhoneNumber } from "./reactcomp_terminals_phonenumbers";
 import { Terminal_Image } from "./reactcomp_terminals_image";
 import { Terminal_Link } from "./reactcomp_terminals_link";
+import { Terminal_Fillin } from "./reactcomp_terminals_fillin";
 
 export interface ITerminalPropsType {
   active: boolean;
@@ -47,19 +49,20 @@ export const TerminalDispatcher = React.memo(
     );
     //*********
     //RERENDERING ISSUE
-    // useSelector(currentTerminalIdx) that changes EVERYTIME word advances thus triggers
-    // rerendering of TerminalDispatcher but NOT actual screen update. Could keep an active/inactive array for all words
-    // on page in state but array are immutable and thus even a single element change requires a copy of entire array
-    // cause rerendering of all sentences
+    // useSelector(currentTerminalIdx) that changes EVERYTIME word advances
+    // thus rerenders of TerminalDispatcher but NOT actual screen update. Could
+    // keep an active/inactive array for all words on page in state but array
+    // are immutable and thus even a single element change requires a copy of
+    // entire array cause rerendering of all sentences
     // console.log(
     //   `<TerminalDispatcher content=${props.terminal.content} />` // props.active=${props.active} props.terminal=${props.terminal} />`
     // );
     // for all terminals made of multiple TerminalInfo blocks, active must identify the specific terminalList
-    // So even if the the component renders the entire compound terminal, active can only be set for a single
-    // terminal
+    // So even if the component renders the entire compound terminal, active
+    // can only be set for a single terminal within compound one.
     //
-    //
-    // Explore using props.children in dispatcher to tranparently dispatch without triggering rerender via useSelector
+    // Explore using props.children in dispatcher to tranparently dispatch
+    // without triggering rerender via useSelector
     //
     // *********
     switch (props.terminal.type) {
@@ -108,6 +111,16 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
+      case TerminalMetaEnumType.fillin:
+        return (
+          <Terminal_Fillin
+            active={
+              currentTerminalIdx >= props.terminal.firstTermIdx &&
+              currentTerminalIdx <= props.terminal.lastTermIdx
+            }
+            terminal={props.terminal}
+          />
+        );
       case TerminalMetaEnumType.image:
         //active should be false regardless
         return (
@@ -152,14 +165,14 @@ export const TerminalDispatcher = React.memo(
       case TerminalMetaEnumType.year:
         break;
       default:
-        return <>unknown terminal "{props.terminal.content}"</>;
+        return <>unknown terminal "{props.terminal.content}!"</>;
     }
   }
 );
 export const Terminal_Acronym = React.memo((props: ITerminalPropsType): any => {
   //  console.log(`<Terminal_acronym> active=${props.active}`);
-  // Rather not trigger dispatch via useSelector but necessary for all multiple terminal words
-  // Rerenders only when acronym is active theough
+  // Rather not trigger dispatch via useSelector but necessary for all multiple
+  // terminal words. Rerenders only when acronym is active theough
   const currentTerminalIdx = useAppSelector(store => store.cursor_terminalIdx); // cause rerendering
   let acronym: IAcronymTerminalMeta = props.terminal
     .meta as IAcronymTerminalMeta;
@@ -210,6 +223,9 @@ export const TerminalNode = React.memo((props: ITerminalNodePropsType): any => {
   let dispatch = useAppDispatch();
   //  const termRef = useSpanRef();
   const terminalRef = useSpanRef();
+  const { terminalFillin, setTerminalFillin } = useContext(
+    TerminalFillinContext
+  );
   useEffect(() => {
     //    console.log(`<TerminalNode> useEffect() active, expecting scrollToView()`);
     /* Consider multiple scrollIntoView modes:
@@ -233,11 +249,37 @@ export const TerminalNode = React.memo((props: ITerminalNodePropsType): any => {
       }
     }
   }, [props.active]);
+  // useEffect(() => {
+  //   console.log(
+  //     `showTerminalIdx=${showTerminalIdx}, offsetIdx=${terminalFillin.offsetIdx}, ${props.terminalInfo.termIdx}`
+  //   );
+  //   let relativeIdx = showTerminalIdx - terminalFillin.offsetIdx;
+  //   if (relativeIdx >= 0 && relativeIdx < terminalFillin.visible.length) {
+  //     terminalFillin.visible[relativeIdx] = true;
+  //     setTerminalFillin(terminalFillin);
+  //     console.log(`showing terminalFillin.visible[${relativeIdx}]=true`);
+  //   }
+  // }, [showTerminalIdx]);
+  let hidden: string = "";
   // refactor the following
+  if (
+    terminalFillin.visible.length > 0 &&
+    terminalFillin.visible.length - 1 <=
+      props.terminalInfo.termIdx - terminalFillin.offsetIdx
+  ) {
+    hidden = !terminalFillin.visible[
+      props.terminalInfo.termIdx - terminalFillin.offsetIdx
+    ]
+      ? ` fillin-prompts-terminal-hidden `
+      : "";
+  }
   if (props.terminalInfo.recitable) {
     let attribute: string = `${
       props.terminalInfo.recitable ? "recitable-word" : ""
-    } ${props.active ? "active" : ""}`;
+    } ${props.active ? "active" : ""} ${hidden}`;
+    if (props.active && props.terminalInfo.responseIdx >= 0) {
+      dispatch(Request.Fillin_setCurrent(props.terminalInfo.termIdx));
+    }
     return (
       <span
         className={`${props.class} ${attribute}`}
diff --git a/reading_fe_app/src/reducers.ts b/reading_fe_app/src/reducers.ts
index 19dd0c4..8c0ec63 100644
--- a/reading_fe_app/src/reducers.ts
+++ b/reading_fe_app/src/reducers.ts
@@ -15,6 +15,7 @@
  *
  **/
 import { CPageLists } from "./pageContext";
+const IDX_INITIALIZER = -9999;
 // import {
 //   ISettings,
 //   ISettingsContext,
@@ -28,14 +29,12 @@ export enum StatusBarMessageType {
 }
 //const IDX_INITIALIZER = -9999; // should be same as baseclasses.ts
 
-// word actions
-const WORD_MATCH = "word/match"; // match word with argument with current word
-//const WORD_VISIT = "word/visit"; // visit word with argument
+const WORD_VISIT = "word/visit"; // visit word with argument
 const WORD_NEXT = "word/next"; // next word in sentence
 const WORD_PREVIOUS = "word/previous"; // previous word in sentence
 //const WORD_RESET = "word/reset"; // first word in page
 const WORD_SELECT = "word/select"; // selected word in sentence
-
+const WORD_SETCURRENTFILLIN = "word/set current fillin";
 // sentence actions
 const SENTENCE_FIRST = "sentence/first"; // position at first word in sent.
 const SENTENCE_NEXT = "sentence/next"; // position at first word of next sent.
@@ -61,7 +60,7 @@ const PAGE_RESTORED = "page/restored";
 const PAGE_HOME = "page/home";
 const PAGE_HOMED = "page/homed";
 const PAGE_HOME_ENABLED = "page/home enabled";
-const PAGE_PREVIOUS_ENABLED = "page/previos enabled";
+const PAGE_PREVIOUS_ENABLED = "page/previous enabled";
 
 // intrapage administrative actions (non-user initiated)
 //const PAGECONTEXT_SET = "pagecontext/set";
@@ -69,9 +68,12 @@ const CONTEXT_SET = "context/set";
 
 //listening actions
 const LISTENING_AVAILABLE = "listening/available";
-const LISTENING_FLUSH = "listening/flush"; // clear transcript
-const LISTENING_FLUSHED = "listening/flushed"; // clear transcript
+// const LISTENING_FLUSH = "listening/flush"; // clear transcript
+// const LISTENING_FLUSHED = "listening/flushed"; // clear transcript
+const LISTENING_MATCH = "listening/match"; // match word with argument with //
 const LISTENING_START = "listening/start";
+// const LISTENING_RETRY = "listening/retry";
+// const LISTENING_RETRY_RESET = "listening/retry reset";
 const LISTENING_STOP = "listening/stop";
 const LISTENING_TOGGLE = "listening/toggle"; // related to start/stop
 
@@ -194,21 +196,16 @@ const Cursor_gotoFirstSection = () => {
     payload: 0
   };
 };
-const Cursor_matchWords = (words: string) => {
-  return {
-    type: WORD_MATCH,
-    payload: words
-  };
-};
 const Cursor_gotoFirstWord = () => {
   // first word of sentence
   return {
     type: SENTENCE_FIRST
   };
 };
-const Cursor_gotoNextWord = () => {
+const Cursor_gotoNextWord = (message?: string) => {
   return {
-    type: WORD_NEXT
+    type: WORD_NEXT,
+    payload: message
   };
 };
 const Cursor_gotoNextSentence = () => {
@@ -243,6 +240,12 @@ const Cursor_acknowledgeTransition = () => {
     type: TRANSITION_ACKNOWLEDGE
   };
 };
+const Fillin_setCurrent = (terminalIdx: number) => {
+  return {
+    type: WORD_SETCURRENTFILLIN,
+    payload: terminalIdx
+  };
+};
 const Message_set = (
   message: string,
   msgType: StatusBarMessageType = StatusBarMessageType.application
@@ -269,12 +272,6 @@ const StatusBar_Message_set = (message: string) => {
     payload: message
   };
 };
-// const StatusBar_Message_clear = () => {
-//   return {
-//     type: STATUSBAR_MESSAGE_SET,
-//     payload: ""
-//   };
-// };
 const Page_load = (page: string, sectionIdx?: number, terminalIdx?: number) => {
   return {
     type: PAGE_LOAD,
@@ -346,16 +343,34 @@ const Recognition_toggle = (maxRetries: number) => {
     payload: maxRetries
   };
 };
-const Recognition_flush = () => {
-  return {
-    type: LISTENING_FLUSH
-  };
-};
-const Recognition_flushed = () => {
+// const Recognition_flush = () => {
+//   return {
+//     type: LISTENING_FLUSH
+//   };
+// };
+// const Recognition_flushed = () => {
+//   return {
+//     type: LISTENING_FLUSHED
+//   };
+// };
+const Recognition_match = (message: string) => {
   return {
-    type: LISTENING_FLUSHED
+    type: LISTENING_MATCH,
+    payload: message
   };
 };
+// const Recognition_retry = (message: string) => {
+//   return {
+//     type: LISTENING_RETRY,
+//     payload: message
+//   };
+// };
+// const Recognition_reset_retry = (message: string) => {
+//   return {
+//     type: LISTENING_RETRY_RESET,
+//     payload: message
+//   };
+// };
 const Recognition_start = (maxRetries: number) => {
   return {
     type: LISTENING_START,
@@ -416,7 +431,6 @@ const Settings_toggle = () => {
   };
 };
 export const Request = {
-  Cursor_matchWords,
   Cursor_gotoFirstSection, // first word in page
   Cursor_gotoFirstSentence, // first word in section
   Cursor_gotoFirstWord, // first word in sentence
@@ -428,6 +442,8 @@ export const Request = {
   Cursor_gotoSectionByIdx,
   //  Cursor_acknowledgeTransition,
 
+  Fillin_setCurrent,
+
   Message_set,
   Message_clear,
 
@@ -454,8 +470,11 @@ export const Request = {
 
   Recognition_toggle,
   Recognition_setAvailability,
-  Recognition_flush,
-  Recognition_flushed,
+  // Recognition_flush,
+  // Recognition_flushed,
+  Recognition_match,
+  // Recognition_retry,
+  // Recognition_reset_retry,
   Recognition_start,
   Recognition_stop,
 
@@ -478,89 +497,6 @@ export const Request = {
   // Speech_announceNewSection,
   // Speech_announceNewSentence
 };
-//   listening_available: boolean;
-//   listening_active: boolean;
-//   listening_flush: boolean;
-//   listening_silenceStartTime: number;
-//
-//   announce_available: boolean;
-//   announce_listening: boolean; // "listening"
-//   announce_newSentence: boolean; //"e.g., "new sentence"
-//   announce_newSection: boolean; //"e.g., "new sentence"
-//
-//   cursor_sectionIdx: number;
-//   cursor_sentenceIdx: number;
-//   cursor_terminalIdx: number;
-//   cursor_newSentence: boolean;
-//   cursor_newSection: boolean;
-//   cursor_newPage: boolean;
-//
-//   pageContext: IPageContext; // context stored outside of redux but accesses within reducer
-// }
-
-/*
-interface IAnnounceReduxState {
-  available: boolean,
-  listening: boolean, // "listening"
-  newSentence: boolean, //"e.g., "new sentence"
-  newSection: boolean, //"e.g., "new sentence"
-}
-function AnnounceReduxInitializer(): IAnnounceReduxState {
-  return {
-    available: false, // "listening"
-    listening: false, // "listening"
-    newSentence: false, //"e.g., "new sentence"
-    newSection: false //"e.g., "new sentence"
-  }
-}
-interface IListeningReduxState {
-  available: boolean;
-  listening: boolean;
-  flush: boolean;
-  silenceStartTime: number;
-}
-function ListeningReduxInitializer(): IListeningReduxState {
-  return {
-    available: false,
-    listening: false,
-    flush: false,
-    silenceStartTime: 0
-  }
-};
-//export const InitialWordsVisitedState = false;
-
-// Reducers - maps new state based on current state and action object (defined above)
-export interface ICursorReduxState {
-  sectionIdx: number;
-  sentenceIdx: number;
-  terminalIdx: number;
-  newSentence: boolean;
-  newSection: boolean;
-  newPage: boolean;
-}
-function CursorReduxInitializer() {
-  return {
-    sectionIdx: -1, // innermost
-    sentenceIdx: -1,
-    terminalIdx: -1,
-    newSentence: false,
-    newSection: false,
-    newPage: false,
-  };
-}
-interface IReduxState {
-  announce: IAnnounceReduxState;
-  cursor: ICursorReduxState;
-  listening: IListeningReduxState;
-  pageContext: IPageContext
-}
-const IReduxStateInitialState: IReduxState = {
-  announce: AnnounceReduxInitializer(),
-  cursor: CursorReduxInitializer(),
-  listening: ListeningReduxInitializer(),
-  pageContext: PageContextInitializer()
-}
-*/
 interface IReduxState {
   announce_available: boolean;
   announce_listening: boolean; // "listening"
@@ -568,11 +504,11 @@ interface IReduxState {
 
   listen_available: boolean;
   listen_active: boolean;
-  listen_flush: boolean;
+  // listen_flush: boolean;
   listen_silenceStartTime: number;
-  listen_retriesExceeded: boolean;
-  listen_retries: number;
-  listen_retries_max: number;
+  // listen_retriesExceeded: boolean;
+  // listen_retries: number;
+  // listen_retries_max: number;
 
   cursor_sectionIdx: number;
   cursor_sentenceIdx: number;
@@ -589,6 +525,9 @@ interface IReduxState {
   cursor_terminalIdx_proposed: number;
   cursor_sectionIdx_proposed: number;
 
+  fillin_currentTerminalIdx: number;
+  fillin_showTerminalIdx: number;
+
   page_requested: string;
   page_loaded: boolean;
   page_section: number;
@@ -620,11 +559,11 @@ const IReduxStateInitialState: IReduxState = {
 
   listen_available: false,
   listen_active: false,
-  listen_flush: false,
+  // listen_flush: false,
   listen_silenceStartTime: 0,
-  listen_retries_max: 0,
-  listen_retries: 0,
-  listen_retriesExceeded: false,
+  // listen_retries_max: 0,
+  // listen_retries: 0,
+  // listen_retriesExceeded: false,
 
   test: false,
   cursor_sectionIdx: 0,
@@ -637,6 +576,9 @@ const IReduxStateInitialState: IReduxState = {
   cursor_beginningOfPageReached: true,
   cursor_endOfPageReached: false,
 
+  fillin_currentTerminalIdx: IDX_INITIALIZER,
+  fillin_showTerminalIdx: IDX_INITIALIZER,
+
   page_requested: "",
   page_loaded: false,
   page_section: 0,
@@ -689,9 +631,9 @@ export const rootReducer = (
       console.log(`end of page?`);
     } else if (terminalIdxs.length === 1) {
       state.cursor_endOfPageReached = false;
-      resetListeningRetries();
+      // resetListeningRetries();
       console.log(
-        `setTerminalState single state transition ${terminalIdxs[0]}`
+        `setTerminalState single state transition from prevTermIdx=${state.cursor_terminalIdx} to nextTermIdx= ${terminalIdxs[0]}`
       );
       if (state.pageContext.isValidTerminalIdx(terminalIdxs[0])) {
         /// set single state
@@ -716,25 +658,29 @@ export const rootReducer = (
     }
   };
   const setToNextTerminalState = () => {
-    resetListeningRetries();
+    // resetListeningRetries();
+    if (state.fillin_currentTerminalIdx === state.cursor_terminalIdx) {
+      state.fillin_showTerminalIdx = state.fillin_currentTerminalIdx;
+      state.fillin_currentTerminalIdx = IDX_INITIALIZER;
+    }
     setTerminalState(
       state.pageContext.nextTerminalIdx(state.cursor_terminalIdx)
     );
   };
   const setToPrevTerminalState = () => {
-    resetListeningRetries();
+    // resetListeningRetries();
     setTerminalState(
       state.pageContext.previousTerminalIdx(state.cursor_terminalIdx)
     );
   };
   const setToNextSentenceTerminalState = () => {
-    resetListeningRetries();
+    // resetListeningRetries();
     setTerminalState([
       state.pageContext.nextSentenceTerminalIdx(state.cursor_terminalIdx)
     ]);
   };
   const setToPrevSentenceTerminalState = () => {
-    resetListeningRetries();
+    // resetListeningRetries();
     setTerminalState([
       state.pageContext.previousSentenceTerminalIdx(state.cursor_terminalIdx)
     ]);
@@ -762,18 +708,13 @@ export const rootReducer = (
       state.cursor_terminalIdx = 0;
     }
   };
-  const incrementListeningRetries = () => {
-    state.listen_retries++;
-    state.listen_retriesExceeded =
-      state.listen_retries_max > 0 &&
-      state.listen_retries > state.listen_retries_max;
-  };
-  const resetListeningRetries = () => {
-    state.listen_retries = 0;
-    state.listen_retriesExceeded = false;
-  };
+  // const resetListeningRetries = () => {
+  //   state.listen_retries = 0;
+  //   state.listen_retriesExceeded = false;
+  // };
   const setListeningMessage = (message: string): string => {
     state.message_state = `${action.type}: ${message}`;
+    console.log(`Listening: ${state.message_state}`);
     return state.message_state;
   };
   switch (action.type) {
@@ -828,9 +769,6 @@ export const rootReducer = (
       state.page_restore_requested = false;
       return state;
     case PAGE_HOME:
-      console.log(
-        `page_home: page restored_request=${state.page_restore_requested}`
-      );
       if (state.page_restore_requested) {
         state.page_home_requested = false;
       } else {
@@ -875,57 +813,21 @@ export const rootReducer = (
         state.cursor_terminalIdx = 0;
       }
       return state;
-    case WORD_MATCH:
-      let wordsHeard: string = action.payload as string;
-      if (
-        wordsHeard !== undefined &&
-        state.pageContext !== undefined &&
-        state.pageContext !== null
-      ) {
-        let expecting: string = state.pageContext.terminalList[
-          state.cursor_terminalIdx
-        ].content.toLowerCase();
-        let expectingAlt: string = state.pageContext.terminalList[
-          state.cursor_terminalIdx
-        ].altrecognition.toLowerCase(); // should .split(" ")
-        // console.log(state.message_listening);
-        // need to handle altRecognition word list against consecutive words heard
-        //   1) Lookahead in words heard list to allow a peek.
-        //      Requires changing for/of loop (straightforward but messy)
-        //   2) create internal state that reflects interim condition without
-        //      advancing terminal state, resetting that state when completely
-        //      or state is no longer valid (matching or not matching the entire
-        //      altReg list words heard.)
-        if (wordsHeard.length > 0) incrementListeningRetries();
-        for (let wordHeard of wordsHeard.split(" ")) {
-          wordHeard = wordHeard.toLowerCase();
-          if (expecting === wordHeard) {
-            setToNextTerminalState();
-            setListeningMessage(`Matched "${expecting}"`);
-          } else if (expectingAlt === wordHeard) {
-            setToNextTerminalState();
-            setListeningMessage(`Matched "${expectingAlt}"`);
-          } else if (
-            expectingAlt.length > 0 &&
-            patternMatch(wordHeard, expectingAlt)
-          ) {
-            setToNextTerminalState();
-            setListeningMessage(`Matched pattern "${expectingAlt}"`);
-          } else {
-            // console.log(
-            setListeningMessage(
-              `Comparing "${wordHeard}"" within ""${wordsHeard}"; Expecting "${expecting}",  "${expectingAlt}". Retries: ${state.listen_retries}.`
-            );
-          }
-        }
-      }
+    case LISTENING_MATCH:
+      // resetListeningRetries();
+      setListeningMessage(action.payload);
+      setToNextTerminalState();
       return state;
     case WORD_NEXT:
+      setListeningMessage(action.payload);
       setToNextTerminalState();
       return state;
     case WORD_PREVIOUS:
       setToPrevTerminalState();
       return state;
+    case WORD_SETCURRENTFILLIN:
+      state.fillin_currentTerminalIdx = +action.payload;
+      return state;
     case SENTENCE_NEXT:
       setToNextSentenceTerminalState();
       return state;
@@ -938,42 +840,46 @@ export const rootReducer = (
     case LISTENING_TOGGLE:
       if (state.listen_available) {
         state.listen_active = !state.listen_active;
-        if (state.listen_active) {
-          state.listen_retries_max = +action.payload;
-          resetListeningRetries();
-        }
+        // if (state.listen_active) {
+        //   state.listen_retries_max = +action.payload;
+        //   resetListeningRetries();
+        // }
       }
       return state;
     case LISTENING_STOP:
       state.listen_active = false;
-      state.listen_retriesExceeded = false;
+      // state.listen_retries = 0;
+      // state.listen_retriesExceeded = false;
       setListeningMessage((!state.listen_active).toString());
       return state;
     case LISTENING_AVAILABLE:
       state.listen_available = action.payload;
       setListeningMessage(state.listen_available.toString());
       return state;
-    case LISTENING_FLUSH:
-      state.listen_flush = true; // resets transcript
-      resetListeningRetries();
-      setListeningMessage("flushing transcript");
-      return state;
-    case LISTENING_FLUSHED:
-      state.listen_flush = false; // resets transcript
-      setListeningMessage("transcript flushed");
-      return state;
-    // case LISTENING_SET_RETRIES_MAX:
-    //   state.listen_retries_max = action.payload;
+    // case LISTENING_FLUSH:
+    //   state.listen_flush = true; // resets transcript
+    //   resetListeningRetries();
+    //   setListeningMessage("flushing transcript");
+    //   return state;
+    // case LISTENING_FLUSHED:
+    //   state.listen_flush = false; // resets transcript
+    //   setListeningMessage("transcript flushed");
+    //   return state;
+    // case LISTENING_RETRY:
+    //   state.listen_retries++;
+    //   state.listen_retriesExceeded =
+    //     state.listen_retries_max > 0 &&
+    //     state.listen_retries > state.listen_retries_max;
+    //   setListeningMessage(action.payload);
+    //   return state;
+    // case LISTENING_RETRY_RESET:
+    //   state.listen_retries = 0;
+    //   state.listen_retriesExceeded = false;
+    //   setListeningMessage(action.payload);
     //   return state;
     case ANNOUNCE_MESSAGE:
       state.announce_message = action.payload; // resets transcript
       return state;
-    // case ANNOUNCE_ENCE:
-    //   state.announce_message = "new sentence"; // resets transcript
-    //   return state;
-    // case ANNOUNCE_NEWSECTION:
-    //   state.announce_message = "new section"; // resets transcript
-    //   return state;
     case ANNOUNCE_ACKNOWLEDGED:
       state.announce_message = ""; // resets transcript
       return state;
@@ -985,7 +891,6 @@ export const rootReducer = (
       state.cursor_endOfPageReached = false;
       state.announce_message = "";
       return state;
-
     case RECITE_START:
       state.recite_requested = true;
       return state;
@@ -1067,7 +972,3 @@ export const rootReducer = (
       return state;
   }
 };
-function patternMatch(content: string, altRecognitionPattern: string): boolean {
-  let pattern: RegExp = new RegExp(altRecognitionPattern);
-  return pattern.test(content);
-}
