diff --git a/reading_fe_app/src/reactcomp_listen.tsx b/reading_fe_app/src/reactcomp_listen.tsx
index f9423f0..bd09821 100644
--- a/reading_fe_app/src/reactcomp_listen.tsx
+++ b/reading_fe_app/src/reactcomp_listen.tsx
@@ -9,6 +9,7 @@
  *
  **/
 import "./App.css";
+import { CPageLists, PageContext } from "./pageContext";
 import listenRedActiveIcon from "./img/button_listen_activeRed.gif";
 import listenIcon from "./img/button_listen.png";
 import listenGhostedIcon from "./img/button_listen_ghosted.png";
@@ -27,25 +28,33 @@ import {
 
 export const ListeningMonitor = () => {
   //console.log = function() {}; // disable console logging
-  const [wordsPreviouslyHeard, setWordsPreviouslyHeard] = useState("");
+  const [wordsHeardPreviously, setWordsHeardPreviously] = useState("");
+  const [wordPosition, setWordPosition] = useState(-1);
+  const [wordPositionPreviously, setWordPositionPreviously] = useState(-1);
+  const [wordRetries, setWordRetries] = useState(0);
+  const resetListeningState = () => {
+    setWordPositionPreviously(-1);
+    setWordPosition(-1);
+    setWordsHeardPreviously("");
+    setWordRetries(0);
+  };
   const dispatch = useAppDispatch();
+
   const listeningRequested: boolean = useAppSelector(
     store => store.listen_active
   );
+  const pageContext: CPageLists = useContext(PageContext)!;
 
   let settingsContext: ISettingsContext = useContext(
     SettingsContext
   ) as ISettingsContext;
+  const maxRetries: number = settingsContext.settings.listen.retries;
   const silenceTimeout: number = settingsContext.settings.listen.timeout;
-  // let queuingDuration: number =
-  //   settingsContext.settings.listen.listeningInterval;
-  const retries: number = useAppSelector(store => store.listen_retries);
-
   interface IRecognitionArguments {
     continuous: boolean;
     language: string;
   }
-  const ContinuousListeningForEnglish: IRecognitionArguments = {
+  const ContinuousListeningInEnglish: IRecognitionArguments = {
     continuous: true,
     language: "en-US"
   };
@@ -58,7 +67,7 @@ export const ListeningMonitor = () => {
   const startSilenceTimer = (): ReturnType<typeof setTimeout> => {
     if (silenceTimerId !== undefined) {
       clearTimeout(silenceTimerId);
-      console.log(`clearing previous silence timer for id=${silenceTimerId}`);
+      // console.log(`clearing previous silence timer for id=${silenceTimerId}`);
     }
     let retval = setTimeout(() => {
       console.log(`SILENCE TIMEOUT TRIGGERED`);
@@ -67,13 +76,13 @@ export const ListeningMonitor = () => {
       SpeechRecognition.abortListening();
       dispatch(Request.Recognition_stop());
     }, silenceTimeout * 1000);
-    console.log(`Starting silence timer for id=${retval}`);
+    // console.log(`Starting silence timer for id=${retval}`);
     setSilenceTimerId(retval);
     return retval;
   };
   const clearSilenceTimer = () => {
     if (silenceTimerIdRef.current !== undefined) {
-      console.log(`clearing silence timer id=${silenceTimerIdRef.current}`);
+      // console.log(`clearing silence timer id=${silenceTimerIdRef.current}`);
       clearTimeout(silenceTimerIdRef.current);
     }
   };
@@ -84,14 +93,13 @@ export const ListeningMonitor = () => {
     resetTranscript,
     listening
   } = useSpeechRecognition();
-
   ////////////////////////////////////
   // Start and stop listening manually
   ////////////////////////////////////
   useEffect(() => {
     if (!listening && listeningRequested) {
       console.log(`restart listening because browser eventually times out`);
-      SpeechRecognition.startListening(ContinuousListeningForEnglish);
+      SpeechRecognition.startListening(ContinuousListeningInEnglish);
     }
   }, [listening, listeningRequested]);
   useEffect(() => {
@@ -102,7 +110,7 @@ export const ListeningMonitor = () => {
       console.log("LISTENING: stop listening requested");
     } else {
       // timeout periodically not
-      SpeechRecognition.startListening(ContinuousListeningForEnglish);
+      SpeechRecognition.startListening(ContinuousListeningInEnglish);
 
       console.log(`LISTENING: start listening with timeout=${silenceTimeout}s`);
       startSilenceTimer();
@@ -111,54 +119,107 @@ export const ListeningMonitor = () => {
       );
     }
   }, [listeningRequested]);
-
+  const expectedTerminalIdx: number = useAppSelector(
+    store => store.cursor_terminalIdx
+  );
   useEffect(() => {
-    let words: string;
+    let wordsHeard: string;
+    let finalTranscriptEncountered: boolean = false;
     if (!listening) {
       // console.log(`LISTENING: No longer listening...`);
       if (listeningRequested) {
         // speech recognition timed out
         // console.log(`NO LONGER LISTENING...BUT LISTENING RESTARTED`);
-        SpeechRecognition.startListening(ContinuousListeningForEnglish); // timeout periodically not
+        SpeechRecognition.startListening(ContinuousListeningInEnglish); // timeout periodically not
       }
     } else {
-      // console.log(`LISTENING...`);
     }
-    {
+    if (listening) {
       if (finalTranscript !== "") {
-        console.log(`final=  ${finalTranscript}`);
-        words = finalTranscript;
+        finalTranscriptEncountered = true;
+        wordsHeard = finalTranscript;
         resetTranscript();
       } else {
-        words = interimTranscript;
+        wordsHeard = interimTranscript;
         console.log(`interim=${interimTranscript}`);
       }
-      console.log(`heard=  ${words}`);
-      // words === wordsPreviouslyHeard) {
-      // need to skip matching if nothing new is recognized. Remember, the
-      // SpeechRecognition engine continues to guess at what was said even
-      // though the speaker hasn't uttered another word. This check is
-      // primarily to try and reduce inadvertant retry increment...
-      // but its not very effective because the engine typically returns
-      // different interpretations of what it heard.
-      // Also, previously heard words should only be compared to words NOT
-      // silence (blanks)
-      if (words.length === 0) {
-        console.log(`detecting silence`);
-      } else if (wordsPreviouslyHeard.includes(words)) {
-        console.log(`detecting only previous words`);
+      console.log(`LISTENING: Heard=  ${wordsHeard}`);
+      if (wordsHeard.length === 0) {
+        resetListeningState();
+        // setWordPosition(-1);
+        // setWordsHeardPreviously("");
+        // setWordPositionPreviously(-1);
+        console.log(
+          `LISTENING: Detecting silence wordPos=${wordPosition} wordPosPrev=${wordPositionPreviously}`
+        );
+        // } else if (wordsPreviouslyHeard === wordsHeard) {
+        //   console.log(`detecting only previous words`);
+      } else if (
+        wordsHeardPreviously.includes(wordsHeard) &&
+        wordPosition === wordPositionPreviously
+      ) {
+        // same word i.e., same word within same words heard list
+        console.log(
+          `LISTENING: Detecting only previous words: "${wordsHeardPreviously}" wordPos=${wordPosition} wordPosPrev=${wordPositionPreviously}`
+        );
       } else {
-        //        setWordsPreviouslyHeard(words);
+        console.log(`LISTENING: Parsing words="${wordsHeard}"`);
+        let wordsHeardList = wordsHeard.split(" ");
+        let matchMessage: string;
+        setWordsHeardPreviously(wordsHeard);
+        setWordPositionPreviously(-1);
         startSilenceTimer();
-        dispatch(Request.Cursor_matchWords(words));
-
-        // in the future, the actual word matching can be brought into this
-        // component and just sent dispatch Cursor_gotoNextWord() and
-        // retriesExceeded.
-        // clean up timer to prevent weird behavior and memory leaks
+        let expecting: string = pageContext.terminalList[
+          expectedTerminalIdx
+        ].content.toLowerCase();
+        let expectingAlt: string = pageContext.terminalList[
+          expectedTerminalIdx
+        ].altrecognition.toLowerCase();
+        let wordPos: number;
+        let wordHeard: string;
+        setWordPositionPreviously(wordPosition);
+        for (
+          wordPos = wordPosition + 1;
+          wordPos < wordsHeardList.length;
+          wordPos++
+        ) {
+          console.log(
+            `LISTENING: Looping wordPos=${wordPos}  wordPosPrev=${wordPositionPreviously}`
+          );
+          wordHeard = wordsHeardList[wordPos].toLowerCase();
+          if (expecting === wordHeard) {
+            setWordPosition(wordPos);
+            setWordRetries(0);
+            matchMessage = `LISTENING: Matched "${expecting}" with ${wordHeard} wordPos=${wordPos} wordPosPrev=${wordPositionPreviously}`;
+            dispatch(Request.Recognition_match(matchMessage));
+            break;
+          } else if (expectingAlt === wordHeard) {
+            setWordPosition(wordPos);
+            setWordRetries(0);
+            matchMessage = `LISTENING: Matched alternative with "${expectingAlt} wordPos=${wordPos} wordPosPrev=${wordPositionPreviously} idx=${expectedTerminalIdx}`;
+            dispatch(Request.Recognition_match(matchMessage));
+            break;
+          } else if (
+            expectingAlt.length > 0 &&
+            patternMatch(wordHeard, expectingAlt)
+          ) {
+            setWordPosition(wordPos);
+            setWordRetries(0);
+            matchMessage = `LISTENING: Matched pattern with "${expectingAlt} wordPos=${wordPos}  wordPosPrev=${wordPositionPreviously} idx=${expectedTerminalIdx}`;
+            dispatch(Request.Recognition_match(matchMessage));
+            break;
+          } else {
+            matchMessage = `LISTENING: Retrying "${expecting}" or  "${expectingAlt}" but hearing word "${wordHeard}" within clause "${wordsHeard}" wordPos=${wordPos}  wordPosPrev=${wordPositionPreviously} with ${wordRetries} retries.`;
+            setWordRetries(wordRetries + 1);
+          }
+        }
+      }
+      if (finalTranscriptEncountered) {
+        resetListeningState();
       }
     }
     return () => {
+      // console.log(`LISTENING: Clearing timer`);
       clearTimeout(silenceTimerIdRef.current!);
     };
   }, [
@@ -167,32 +228,37 @@ export const ListeningMonitor = () => {
     transcript,
     interimTranscript,
     finalTranscript,
-    resetTranscript
+    resetTranscript,
+    expectedTerminalIdx
   ]);
-  const retriesExceeded = useAppSelector(store => store.listen_retriesExceeded);
+  // const retriesExceeded = useAppSelector(store => store.listen_retriesExceeded);
   const reciteWordRequested = useAppSelector(
     store => store.recite_word_requested
   );
   useEffect(() => {
-    console.log(`LISTENING: retries exceeded; reset transcript`);
-    if (retriesExceeded) {
+    // console.log(`LISTENING: retries`);
+    if (wordRetries > maxRetries) {
+      // console.log(`LISTENING: retries exceeded; reset transcript`);
       if (!reciteWordRequested) {
+        // console.log(`LISTENING: retries exceeded; recite not requested`);
         resetTranscript();
         dispatch(Request.Recite_currentWord());
       } else {
-        dispatch(Request.Cursor_gotoNextWord());
+        // console.log(`LISTENING: retries exceeded; goto next word`);
+        dispatch(Request.Cursor_gotoNextWord("retries exceeded"));
+        setWordRetries(0);
       }
     }
-  }, [retriesExceeded, reciteWordRequested]);
-  const flushRequested: boolean = useAppSelector(store => store.listen_flush);
-  useEffect(() => {
-    if (flushRequested) {
-      console.log(`LISTENING: flushing transcript queue`);
-      resetTranscript();
-      dispatch(Request.Recognition_flushed());
-    } else {
-    }
-  }, [flushRequested]);
+  }, [wordRetries, reciteWordRequested]);
+  // const flushRequested: boolean = useAppSelector(store => store.listen_flush);
+  // useEffect(() => {
+  //   if (flushRequested) {
+  //     console.log(`LISTENING: flushing transcript queue`);
+  //     resetTranscript();
+  //     dispatch(Request.Recognition_flushed());
+  //   } else {
+  //   }
+  // }, [flushRequested]);
 
   ///////////////////////
   // Transition callbacks
@@ -203,7 +269,9 @@ export const ListeningMonitor = () => {
   useEffect(() => {
     if (newSentence) {
       console.log(`LISTENING: new sentence transition`);
-      dispatch(Request.Recognition_flush());
+      //      dispatch(Request.Recognition_flush());
+      resetListeningState();
+      resetTranscript();
     }
   }, [newSentence]);
   const message_listen: string = useAppSelector(
@@ -532,3 +600,7 @@ export const NotificationModeRadioButton = (
     </>
   );
 };
+function patternMatch(content: string, altRecognitionPattern: string): boolean {
+  let pattern: RegExp = new RegExp(altRecognitionPattern);
+  return pattern.test(content);
+}
diff --git a/reading_fe_app/src/reactcomp_main.tsx b/reading_fe_app/src/reactcomp_main.tsx
index 4717701..f369d30 100644
--- a/reading_fe_app/src/reactcomp_main.tsx
+++ b/reading_fe_app/src/reactcomp_main.tsx
@@ -25,7 +25,7 @@ export const ReadingApp = () => {
     settings: _settings,
     saveSettings: _setSettings
   };
-  // const restorePageRequested = useAppSelector(
+  // const restoreRequested = useAppSelector(
   //   store => store.page_restore_requested
   // );
   let dispatch = useAppDispatch();
@@ -37,7 +37,7 @@ export const ReadingApp = () => {
   if (_settings.config.homePage.length === 0) {
     dispatch(Request.Page_load("sitemap"));
   } else {
-    // } else if (!restorePageRequested) {
+    // } else if (!restoreRequested) {
     dispatch(Request.Page_home());
   }
   return (
diff --git a/reading_fe_app/src/reactcomp_page.tsx b/reading_fe_app/src/reactcomp_page.tsx
index 0503636..88db30f 100644
--- a/reading_fe_app/src/reactcomp_page.tsx
+++ b/reading_fe_app/src/reactcomp_page.tsx
@@ -24,8 +24,8 @@
  *    subsequently assigned within the reducer for eventual consumption by
  *    react component(s).
  *
- * Even though reducer state tracks both the pageRequested and pageContext
- * changes, internal component state variable isPageLoaded tracks when new
+ * Even though reducer state tracks both the Requested and pageContext
+ * changes, internal component state variable canRender tracks when new
  * load is requested but not yet properly loaded.
  *
  * The context and content are not loaded until successful to prevent the
@@ -51,13 +51,14 @@ import { PageHeader } from "./reactcomp_pageheader";
 import { PageFooter } from "./reactcomp_pagefooter";
 import { SettingsDialog } from "./reactcomp_settings";
 import { SectionDispatcher } from "./reactcomp_sections";
+// import { FillinSectionContexts, IFillinSectionContexts } from "./fillinContexts";
+
 // import { StatusBarMessageType } from "./reducers";
 
 interface IPreviousPageArrayItem {
   page: string;
   currentTermIdx: number;
 }
-
 export interface IPagePropsType {
   appName: string;
 }
@@ -66,12 +67,12 @@ export const Page = React.memo((props: IPagePropsType) => {
   const [parseError, setParseError] = useState<string | null>(null);
   const [pageContent, setPageContent] = useState<IPageContent | null>(null);
   const [pageContext, setPageContext] = useState<CPageLists | null>(null);
-  const [isPageLoaded, setIsPageLoaded] = useState<boolean>(true);
+  const [canRender, setCanRender] = useState<boolean>(true);
   const [previousPages, setPreviousPages] = useState<IPreviousPageArrayItem[]>(
     []
   );
   // Strictly current saves page state between page request and successful page
-  // load so this current page can be  pushed on PreviousPages stack iff next page loads successfully.
+  // load so this current page can be pushed onto PreviousPages stack iff next page loads successfully.
   const [currentPage, setCurrentPage] = useState<string>("");
   const [currentIdx, setCurrentIdx] = useState<number>(0);
   const { isActive, toggleDialog } = useDialog();
@@ -96,36 +97,45 @@ export const Page = React.memo((props: IPagePropsType) => {
       .then(
         data => {
           try {
-            setPageContent(data as IPageContent);
-            message = `Changing page context for "${pageRequested}"`;
-            if (pageContent !== undefined && pageContent !== null) {
-              if (data.version !== PageContentVersion) {
-                setParseError(
-                  `version mismatch. Expected ${PageContentVersion} but encountered ${data.version} in content`
-                );
-              } else {
-                let pageContext: CPageLists = new CPageLists(
-                  pageContent.terminalList,
-                  pageContent.headingList,
-                  pageContent.sectionList,
-                  pageContent.sentenceList,
-                  pageContent.linkList
-                );
-                if (pageContext !== null) {
-                  message = `Loaded page context for "${pageRequested}"`;
-                  setPageContext(pageContext);
-                  dispatch(Request.Page_setContext(pageContext));
-                  dumpPreviousPageStack("beforePageLoaded");
-                  setIsPageLoaded(true);
-                  dumpPreviousPageStack("afterPageLoaded");
-                  //                setCurrentPage(pageRequested);
-                  //                dispatch(Request.Page_loaded(true));
-                } else {
-                  message = `Loading page context failed for "${pageRequested}"`;
-                }
-                //              dispatch(Request.StatusBar_Message_set(message));
-              }
-            }
+            if (data.version !== PageContentVersion) {
+              setParseError(
+                `version mismatch. Expected ${PageContentVersion} but encountered ${data.version} in content`
+              );
+            } else {
+              let content: IPageContent = data as IPageContent;
+              message = `Changing page context for "${pageRequested}"`;
+              setPageContext(null);
+              let pageLists: CPageLists = new CPageLists(
+                content.terminalList,
+                content.headingList,
+                content.sectionList,
+                content.sentenceList,
+                content.linkList,
+                content.fillinList
+              );
+              message = `Loaded page context for "${pageRequested}"`;
+              // console.log(`settingSectionFillin`);
+              // // loop through fillinList
+              // FillinSectionContexts = new IFillinSectionContexts[content.fillinList.length]
+              // for (const fillin of content.fillinList) {
+              //   ISectionFillinItem\
+              //
+              // }
+
+              console.log(`settingPageContent`);
+              setPageContent(content);
+              console.log(`setPageContent`);
+              console.log(`settingPageContext`);
+              setPageContext(pageLists);
+              console.log(`setPageContext`);
+              dispatch(Request.Page_setContext(pageLists));
+              // dumpPreviousPageStack("beforePageLoaded");
+              setCanRender(true);
+              // dumpPreviousPageStack("afterPageLoaded");
+              //                setCurrentPage(pageRequested);
+              //                dispatch(Request.Page_loaded(true));
+              message = `Loading page context failed for "${pageRequested}"`;
+            } // version check
           } catch (e) {
             let message: string = (e as Error).message;
             message = `Encountered unexpected fetching error: ${message}`;
@@ -133,19 +143,30 @@ export const Page = React.memo((props: IPagePropsType) => {
           }
         },
         error => {
-          setParseError(error);
+          // some other parseError
+          if (parseError === null) setParseError(error);
         }
       );
   };
-  let dispatch = useAppDispatch();
   const settingsContext: ISettingsContext = useContext(SettingsContext)!;
   const distDir: string = settingsContext.settings.config.distDir;
-  const homePage: string = settingsContext.settings.config.homePage;
+  const homePage: string = `homepage_${settingsContext.settings.config.homePage}`;
   const pageLoaded: boolean = useAppSelector(store => store.page_loaded);
-  let message: string = "";
+  const pageRequested: string = useAppSelector(store => store.page_requested);
+  const pageRestoreRequested: boolean = useAppSelector(
+    store => store.page_restore_requested
+  );
+  const pageHomeRequested: boolean = useAppSelector(
+    store => store.page_home_requested
+  );
   const currentTermIdx: number = useAppSelector(
     store => store.cursor_terminalIdx
   );
+  const pagePopRequested: boolean = useAppSelector(
+    store => store.page_pop_requested
+  );
+  let dispatch = useAppDispatch();
+  let message: string = "";
   const dumpPreviousPageStack = (message: string) => {
     //  return; //disable dumpPreviousPageStack
     let elString: string = "";
@@ -155,16 +176,12 @@ export const Page = React.memo((props: IPagePropsType) => {
     elString = elString.length > 0 ? elString : "(empty)";
     console.log(`${message}: previousPage Stack ${elString} `);
   };
-  const pageRequested: string = useAppSelector(store => store.page_requested);
-  const pageRestoreRequested: boolean = useAppSelector(
-    store => store.page_restore_requested
-  );
   useEffect(() => {
     // Initiates page load requested but not yet loaded
     if (
       !pageLoaded &&
-      currentPage.length > 0 &&
-      currentPage !== pageRequested
+      currentPage.length > 0
+      //&& currentPage !== pageRequested // not a reload
     ) {
       previousPages.push({
         page: currentPage,
@@ -172,58 +189,57 @@ export const Page = React.memo((props: IPagePropsType) => {
       });
     }
     if (previousPages.length > 0) {
-      dispatch(Request.Page_homeEnabled(true));
-      dispatch(Request.Page_previousEnabled(true));
+      dispatch(Request.Page_homeEnabled(true)); // unghost icon
+      dispatch(Request.Page_previousEnabled(true)); // unghost icon
     }
-    dumpPreviousPageStack("initial page request");
-    setIsPageLoaded(
+    // dumpPreviousPageStack("initial page request");
+    setCanRender(
       !(pageRequested !== undefined && pageRequested !== null && !pageLoaded)
     );
 
-    fetchRequest(distDir + pageRequested + ".json");
-  }, [distDir, pageRequested, pageLoaded, pageRestoreRequested]);
+    // if (pageRequested.length > 0) {
+    //   setPageContext(null);
+    //   fetchRequest(distDir + pageRequested + ".json");
+    // }
+  }, [pageRequested, pageLoaded, pageRestoreRequested, currentPage]);
 
   useEffect(() => {
     // requested page loading complete
-    if (!isPageLoaded) {
+    if (!canRender) {
       dispatch(Request.Page_loaded(true));
-      setIsPageLoaded(true);
+      //      setCanRender(true);
       //      setPreviousPages(previousPages);
       setCurrentPage(pageRequested);
-      dumpPreviousPageStack("!isPageLoaded");
+      // dumpPreviousPageStack("!canRender");
 
       // if requested page is home page then clear stack!
     } else {
       // save previous page requested after page loaded for push later
       setCurrentPage(pageRequested);
     }
-  }, [pageContent]);
+  }, [canRender]);
 
   useEffect(() => {
     if (pageRequested === currentPage) setCurrentIdx(currentTermIdx);
   }, [pageRequested, currentPage, currentTermIdx]);
 
-  const pageHomeRequested: boolean = useAppSelector(
-    store => store.page_home_requested
-  );
   useEffect(() => {
     if (pageHomeRequested) {
       console.log(`home requested`);
       setPreviousPages([]);
       setCurrentPage("");
       setCurrentIdx(0);
-      dispatch(Request.Page_load(`homepage_${homePage}`));
+      dispatch(Request.Page_load(homePage));
+      dispatch(Request.Page_homeEnabled(false));
       dispatch(Request.Page_homed());
     }
   }, [pageHomeRequested, homePage]);
 
-  const pagePopRequested: boolean = useAppSelector(
-    store => store.page_pop_requested
-  );
   useEffect(() => {
     // pop requested
     if (pagePopRequested) {
       console.log(`pop requested`);
+      previousPages.pop()!;
       let previousPage: IPreviousPageArrayItem = previousPages.pop()!;
       if (previousPage !== undefined) {
         console.log(
@@ -231,14 +247,14 @@ export const Page = React.memo((props: IPagePropsType) => {
         );
         setCurrentPage("");
         setCurrentIdx(0);
-        dumpPreviousPageStack("pagePopRequested");
+        // dumpPreviousPageStack("pagePopRequested");
         dispatch(
           Request.Page_load(previousPage.page, 0, previousPage.currentTermIdx)
         );
       } else {
         console.log(`previous page stack empty`);
       }
-      if (previousPages.length === 0) {
+      if (previousPages.length === 0 || previousPage.page === homePage) {
         dispatch(Request.Page_previousEnabled(false));
         dispatch(Request.Page_homeEnabled(false));
       }
@@ -257,30 +273,55 @@ export const Page = React.memo((props: IPagePropsType) => {
     }
   }, [pageRestoreRequested]);
 
-  if (pageLoaded) {
+  //////////
+  // pageHomeRequested pagePopRequested pageRestoreRequested should be
+  // translated into page_requested and
+  // should all be processes in render code and not useEffect() to avoid
+  // undesirable/unpredictable side effects
+  //////////
+
+  // Translate possible actions into page load
+  //iff canRender === false
+
+  //PAGE REQUESTS
+  //PAGE LOAD
+  //   if (pageRequested === currentPage) {
+  //     console.log(`no direct page requested`);
+  //     dispatch(Request.Page_loaded(true)); // cancel loading
+  // } else {  //PAGE LOAD
+  //     console.log(`page load requested ${pageRequested}`);
+  // }
+
+  if (!pageLoaded) {
+    // page requested already
     message = `Loaded page "${pageRequested}.json"`;
-    if (pageRequested !== currentPage) setCurrentPage(pageRequested);
-    dumpPreviousPageStack("pageLoaded");
-  } else if (responseError) {
-    message = `Encountered response error while loading "${pageRequested}.json": ${responseError}`;
-  } else if (parseError) {
-    const syntaxError: string =
-      "SyntaxError: Unexpected token < in JSON at position 0";
-    if (syntaxError.indexOf(parseError) === 0) {
-      message = `Encountered incompatible JSON format while loading for "${pageRequested}"`;
+    if (pageRequested.length === 0) {
+    } else if (pageRequested !== currentPage) {
+      message = `loading new page "${pageRequested} over current ${currentPage}"`;
+
+      fetchRequest(distDir + pageRequested + ".json");
+      setCurrentPage(pageRequested); // should be in useEffect() pageloaded
     } else {
-      message = `Encountered parsing error while loading "${pageRequested}.json": ${parseError}`;
+      message = `loading new page "${pageRequested} over current ${currentPage}"`;
     }
+    // dumpPreviousPageStack("pageLoaded");
+  } else if (parseError) {
+    message = parseError;
+  } else if (responseError) {
+    message = `Encountered response error while loading "${pageRequested}.json": ${responseError}`;
+  } else if (pageRequested.length === 0) {
+    message = `Waiting...unknown page requested`;
   } else {
-    message = `Waiting for page to load for "${pageRequested}"`;
+    message = `Waiting for page to load for "${pageRequested}..."`;
   }
   console.log(message);
   // React is complaining
   // need to wait until after <StatusBar is rendered OR  use
   // another means to detect that <StatusBar/> is loaded besides
   // surrogate pageContext
-
   if (pageContext !== null) {
+    /////// should be pageRenderable
+    console.log(`rendering page1`);
     return (
       <PageContext.Provider value={pageContext}>
         <div className="page">
@@ -293,6 +334,7 @@ export const Page = React.memo((props: IPagePropsType) => {
       </PageContext.Provider>
     );
   } else {
+    console.log(`rendering page2`);
     return <div className="loadingAnnouncement">{message}</div>;
   }
 });
diff --git a/reading_fe_app/src/reactcomp_sections.tsx b/reading_fe_app/src/reactcomp_sections.tsx
index 3626fa5..d2fe301 100644
--- a/reading_fe_app/src/reactcomp_sections.tsx
+++ b/reading_fe_app/src/reactcomp_sections.tsx
@@ -19,7 +19,7 @@ import {
   ISectionParagraphVariant
 } from "./pageContentType";
 import { Section_imageEntry } from "./reactcomp_sections_imageEntry";
-//import { Settings } from "./reactcomp_settings";
+import { Section_fillin } from "./reactcomp_section_fillin";
 import { Sentence } from "./reactcomp_sentences";
 
 export interface ISectionPropsType {
@@ -54,7 +54,8 @@ export const SectionDispatcher = React.memo((props: ISectionPropsType) => {
       // need to group because component will recursively render zero or more of each
       return <Section_Lists active={props.active} section={props.section} />;
     case SectionVariantEnumType.fillin:
-    case SectionVariantEnumType.fillin_list:
+      return <Section_fillin active={props.active} section={props.section} />;
+    //      return <div>section fillin response</div>;
     case SectionVariantEnumType.image_entry:
       return (
         <Section_imageEntry active={props.active} section={props.section} />
diff --git a/reading_fe_app/src/reactcomp_sections_imageEntry.tsx b/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
index 9b6c7bd..63b1fdb 100644
--- a/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
+++ b/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
@@ -44,11 +44,13 @@ export const Section_imageEntry = React.memo(
     let captions = imageEntry.captions as ISectionContent[];
     let className: string =
       imageEntry.layout.charAt(0).toLowerCase() === "l"
-        ? "imageentry-container-" + ImageEntryLayoutEnumType.left.toString()
-        : "imageentry-container-" + ImageEntryLayoutEnumType.above.toString();
-    let vdividerClassName = className + "-vdivider";
-    let hdividerClassName = className + "-hdivider";
+        ? `imageentry-container-${ImageEntryLayoutEnumType.left.toString()}`
+        : `imageentry-container-${ImageEntryLayoutEnumType.above.toString()}`;
+    let vdividerClassName = `${className}-vdivider`;
+    let hdividerClassName = `${className}-hdivider width=${imageEntry.percent}`;
     console.log(`imageEntry.percent ${imageEntry.percent}`);
+    // set width by changing --imageentry-min-image-width
+    // document.documentElement.style.setProperty()
     return (
       <>
         <div className={hdividerClassName}></div>
diff --git a/reading_fe_app/src/reactcomp_settings.tsx b/reading_fe_app/src/reactcomp_settings.tsx
index 7320f34..0f95cc6 100644
--- a/reading_fe_app/src/reactcomp_settings.tsx
+++ b/reading_fe_app/src/reactcomp_settings.tsx
@@ -110,7 +110,7 @@ export const SettingsDialog = (props: ISettingsDialogPropsType) => {
     setModified(false);
     // setNewSettings(SettingsCloner(settingsContext));
     props.hide();
-    dispatch(Request.Test_set());
+    //    dispatch(Request.Test_set());
   };
   let OkIcons = modified ? OkIcon : OkIcon_ghosted;
   let dispatch = useAppDispatch();
diff --git a/reading_fe_app/src/reactcomp_terminals.tsx b/reading_fe_app/src/reactcomp_terminals.tsx
index fac87c0..56fa05e 100644
--- a/reading_fe_app/src/reactcomp_terminals.tsx
+++ b/reading_fe_app/src/reactcomp_terminals.tsx
@@ -16,7 +16,7 @@
 import React from "react";
 import { Request } from "./reducers";
 import { useAppDispatch, useAppSelector, useSpanRef } from "./hooks";
-import { useEffect } from "react";
+import { useContext, useEffect } from "react";
 
 // is this really necessary if availablility is removed below
 import {
@@ -25,12 +25,14 @@ import {
   IAcronymTerminalMeta,
   TerminalMetaEnumType
 } from "./pageContentType";
+import { TerminalFillinContext } from "./fillinContext";
 
 import { Terminal_Date } from "./reactcomp_terminals_dates";
 import { Terminal_Emailaddress } from "./reactcomp_terminals_emailaddress";
 import { Terminal_PhoneNumber } from "./reactcomp_terminals_phonenumbers";
 import { Terminal_Image } from "./reactcomp_terminals_image";
 import { Terminal_Link } from "./reactcomp_terminals_link";
+import { Terminal_Fillin } from "./reactcomp_terminals_fillin";
 
 export interface ITerminalPropsType {
   active: boolean;
@@ -47,19 +49,20 @@ export const TerminalDispatcher = React.memo(
     );
     //*********
     //RERENDERING ISSUE
-    // useSelector(currentTerminalIdx) that changes EVERYTIME word advances thus triggers
-    // rerendering of TerminalDispatcher but NOT actual screen update. Could keep an active/inactive array for all words
-    // on page in state but array are immutable and thus even a single element change requires a copy of entire array
-    // cause rerendering of all sentences
+    // useSelector(currentTerminalIdx) that changes EVERYTIME word advances
+    // thus rerenders of TerminalDispatcher but NOT actual screen update. Could
+    // keep an active/inactive array for all words on page in state but array
+    // are immutable and thus even a single element change requires a copy of
+    // entire array cause rerendering of all sentences
     // console.log(
     //   `<TerminalDispatcher content=${props.terminal.content} />` // props.active=${props.active} props.terminal=${props.terminal} />`
     // );
     // for all terminals made of multiple TerminalInfo blocks, active must identify the specific terminalList
-    // So even if the the component renders the entire compound terminal, active can only be set for a single
-    // terminal
+    // So even if the component renders the entire compound terminal, active
+    // can only be set for a single terminal within compound one.
     //
-    //
-    // Explore using props.children in dispatcher to tranparently dispatch without triggering rerender via useSelector
+    // Explore using props.children in dispatcher to tranparently dispatch
+    // without triggering rerender via useSelector
     //
     // *********
     switch (props.terminal.type) {
@@ -108,6 +111,16 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
+      case TerminalMetaEnumType.fillin:
+        return (
+          <Terminal_Fillin
+            active={
+              currentTerminalIdx >= props.terminal.firstTermIdx &&
+              currentTerminalIdx <= props.terminal.lastTermIdx
+            }
+            terminal={props.terminal}
+          />
+        );
       case TerminalMetaEnumType.image:
         //active should be false regardless
         return (
@@ -152,14 +165,14 @@ export const TerminalDispatcher = React.memo(
       case TerminalMetaEnumType.year:
         break;
       default:
-        return <>unknown terminal "{props.terminal.content}"</>;
+        return <>unknown terminal "{props.terminal.content}!"</>;
     }
   }
 );
 export const Terminal_Acronym = React.memo((props: ITerminalPropsType): any => {
   //  console.log(`<Terminal_acronym> active=${props.active}`);
-  // Rather not trigger dispatch via useSelector but necessary for all multiple terminal words
-  // Rerenders only when acronym is active theough
+  // Rather not trigger dispatch via useSelector but necessary for all multiple
+  // terminal words. Rerenders only when acronym is active theough
   const currentTerminalIdx = useAppSelector(store => store.cursor_terminalIdx); // cause rerendering
   let acronym: IAcronymTerminalMeta = props.terminal
     .meta as IAcronymTerminalMeta;
@@ -210,6 +223,9 @@ export const TerminalNode = React.memo((props: ITerminalNodePropsType): any => {
   let dispatch = useAppDispatch();
   //  const termRef = useSpanRef();
   const terminalRef = useSpanRef();
+  const { terminalFillin, setTerminalFillin } = useContext(
+    TerminalFillinContext
+  );
   useEffect(() => {
     //    console.log(`<TerminalNode> useEffect() active, expecting scrollToView()`);
     /* Consider multiple scrollIntoView modes:
@@ -233,11 +249,41 @@ export const TerminalNode = React.memo((props: ITerminalNodePropsType): any => {
       }
     }
   }, [props.active]);
+  // useEffect(() => {
+  //   console.log(
+  //     `showTerminalIdx=${showTerminalIdx}, offsetIdx=${terminalFillin.offsetIdx}, ${props.terminalInfo.termIdx}`
+  //   );
+  //   let relativeIdx = showTerminalIdx - terminalFillin.offsetIdx;
+  //   if (relativeIdx >= 0 && relativeIdx < terminalFillin.visible.length) {
+  //     terminalFillin.visible[relativeIdx] = true;
+  //     setTerminalFillin(terminalFillin);
+  //     console.log(`showing terminalFillin.visible[${relativeIdx}]=true`);
+  //   }
+  // }, [showTerminalIdx]);
+  let hidden: string = "";
   // refactor the following
+  if (
+    terminalFillin.visible.length > 0 &&
+    terminalFillin.visible.length - 1 <=
+      props.terminalInfo.termIdx - terminalFillin.offsetIdx
+  ) {
+    hidden = !terminalFillin.visible[
+      props.terminalInfo.termIdx - terminalFillin.offsetIdx
+    ]
+      ? ` fillin-prompts-terminal-hidden `
+      : "";
+  }
   if (props.terminalInfo.recitable) {
     let attribute: string = `${
       props.terminalInfo.recitable ? "recitable-word" : ""
-    } ${props.active ? "active" : ""}`;
+    } ${props.active ? "active" : ""} ${hidden}`;
+    if (
+      props.active &&
+      props.terminalInfo.fillin.responseIdx >= 0 &&
+      props.terminalInfo.fillin.sectionIdx >= 0
+    ) {
+      dispatch(Request.Fillin_setCurrent(props.terminalInfo.termIdx));
+    }
     return (
       <span
         className={`${props.class} ${attribute}`}
