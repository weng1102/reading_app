/*******************************************
 * Reading Monitor v2.0
 * (c) 2017, 2018, 2019, 2020 by Wen Eng. All rights reserved.
 ********************************************/
'use strict';
const TokenType = {
    CONTRACTION: 'MLTAG.CONTRACTION',
    USD: 'MLTAG.USD',
    USD_END: 'MLTAG.USDCURRENCY_END',
    DATE1: 'MLTAG.DATE1',
    DATE2: 'MLTAG.DATE2',
    DATE3: 'MLTAG.DATE3',
    DATE_END: 'MLTAG.DATE_END',
    EMAILADDRESS: 'MLTAG_EMAILADDRESS',
    EMAILADDRESS_END: 'MLTAG.EMAILADDRESS_END',
    FILLIN: 'MLTAG.FILLIN',
    FILLIN_END: 'MLTAG.FILLINTAG_END',
    NUMBER: 'NUMBER',
    NUMBER_WITHCOMMAS: 'MLTAG.NUMBER_WITHCOMMAS',
    NUMBER_WITHCOMMAS_END: 'MLTAG.NUMBER_WITHCOMMASEND',
    MLTAG: 'MLTAG',
    MLTAG_END: 'MLTAG_END',
    MLTAG_SELFCLOSING: 'MLTAG_SELFCLOSING',
    PHONENUMBER: 'MLTAG.PHONENUMBER',
    PHONENUMBER_END: 'MLTAG.PHONENUMBER_END',
    PUNCTUATION: 'PUNCTUATION',
    PUNCTUATION_APOSTROPHE: 'PUNCTUATION.APOSTROPHE',
    PUNCTUATION_ATSIGN: 'PUNCTUATION.ATSIGN',
    PUNCTUATION_COLON: 'PUNCTUATION.COLON',
    PUNCTUATION_COMMA: 'PUNCTUATION.COMMA',
    PUNCTUATION_DASH: 'PUNCTUATION.DASH',
    PUNCTUATION_DOT: 'PUNCTUATION.DOT',
    PUNCTUATION_DOUBLEQUOTE: 'PUNCTUATION.DOUBLEQUOTE',
    PUNCTUATION_FORWARDSLASH: 'PUNCTUATION_FORWARDSLASH',
    PUNCTUATION_LPAREN: 'PUNCTUATION.LPAREN',
    PUNCTUATION_RPAREN: 'PUNCTUATION.RPAREN',
    PUNCTUATION_USD: 'PUNCTUATION.USDSIGN',
    TBD: 'TBD',
    TIME: 'MLTAG.TIME',
    TIME_END: 'MLTAG.TIME_END',
    TOKEN: 'MLTAG.EXPLICITTOKEN',
    TOKEN_END: 'MLTAG.EXPLICITTOKEN_END',
    UNHANDLED: '*****UNHANDLED*****',
    WORD: 'WORD',
    WHITESPACE: 'WHITESPACE'
};
const TokenTag = {
    ATSIGN: '@',
    DATE1: '<date1>',
    DATE2: '<date2>',
    DATE3: '<date3>',
    CONTRACTION: '<contraction>',
    CONTRACTION_D: '<contraction d>',
    CONTRACTION_LL: '<contraction ll>',
    CONTRACTION_M: '<contraction m>',
    CONTRACTION_RE: '<contraction re>',
    CONTRACTION_S: '<contraction s>',
    CONTRACTION_NT: '<contraction nt>',
    CONTRACTION_VE: '<contraction ve>',
    POSSESSIVE_S: '<possessive>',
    EMAILADDRESS: '<emailaddr>',
    FILLIN: '<fillin>',
    FORWARDSLASH: '/',
    APOSTROPHE: "'",
    COLON: ':',
    COMMA: ',',
    DASH: '-',
    DOUBLEQUOTE: '""',
    DOT: '.',
    LPAREN: '(',
    NUMBER_WITHCOMMAS: '<numberwcommas>',
    RPAREN: ')',
    LANGLEBRACKET: '<',
    PHONENUMBER: '<telephone number>',
    RANGLEBRACKET: '>',
    TBD: "",
    TIME: '<time>',
    TOKEN: '<token>',
    URL: '<url>',
    USD: '<usd>',
    USDSIGN: '$',
    WORD: 'WORD'
};
const ParserNodeType = {
    WORD: 'WORD',
    DATE: 'DATE',
    TIME: 'TIME',
    WHITESPACE: 'WHITESPACE',
    MLSELFCLOSINGTAG: 'HTMLSELFCLOSINGTAG',
    // Requires semantic analysis to recombine WORD+, PUNCTUATIONS+
    EMAILADDRESS: 'EMAILADDRESS',
    URL: 'URL',
    STREETNUMBER: 'STREETNUMBER',
    POSSESSIVE: 'POSSESSIVE',
    PHONENUMBER: 'PHONENUMBER',
    CONTRACTION: 'CONTRACTION',
    TOKEN: 'TOKEN',
    USD: 'USD',
    NUMBER: 'NUMBER',
    DECIMAL: 'DECIMAL',
    TITLE: 'TITLE',
    // These HTMLtags and attributes will be propagated for FORMATTING ONLY
    MLSTARTTAG: 'MLSTARTTAG',
    MLENDTAG: 'MLENDTAG',
    MLTAG: "MLTAG",
    MLSELFCLOSINGTAG: 'HTMLSELFCLOSINGTAG',
    HTMLSTARTTAG: "HTMLSTARTTAG",
    HTMLENDTAG: "HTMLENDTAG",
    HTMLATTRLIST: 'HTMLATTRLIST',
    HTMLSELFCLOSINGTAG: 'HTMLTAG_SELFCLOSE',
    TBD: 'TBD',
    WORD: 'WORD'
};
const MarkupTokenTypeList = [
    { tag: TokenTag.USD,
        type: TokenType.USD,
        pattern: /(?<=^|\W)\$(([1-9]\d{0,2}(,\d{3})*)|(([1-9]\d*)?\d))(\.\d\d)?(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.EMAILADDRESS,
        type: TokenType.EMAILADDRESS,
        pattern: /(?<=^|\W)([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})(?=(?=\s|\W|$|[.!?\\-]))/g },
    { tag: TokenTag.PHONENUMBER,
        type: TokenType.PHONENUMBER,
        pattern: /(?<=^|\W)\(\d{3}\)\s\d{3}-\d{4}(?=(\W|$))/g },
    { tag: TokenTag.TIME,
        type: TokenType.TIME,
        pattern: /(?<=^|\W)([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(?=(\W|$))/g },
    { tag: TokenTag.DATE1,
        type: TokenType.DATE1,
        pattern: /(?<=^|\W)((31(?!\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\b|t)t?|Nov)(ember)?)))|((30|29)(?!\ Feb(ruary)?))|(29(?=\ Feb(ruary)?\ (((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])\s*(Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\b|t)t?|Nov|Dec)(ember)?)\ ((1[6-9]|[2-9]\d)\d{2})(?=\s)/g },
    { tag: TokenTag.DATE2,
        type: TokenType.DATE2,
        pattern: /(?<=^|\W)(Jan(.|(uary))?|Feb(.|(ruary))?|Ma(r(.|(ch))?|y)|Apr(.|(il))?|Jul(.|(y))?|Jun(.|(e))?|Aug(.|(ust))?|Oct(.|(ober))?|(Sep(?=\b|t)t?|Nov|Dec)(.|(ember))?)\ ((31(?!\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\b|t)t?|Nov)(ember)?)))|((30|29)(?!\ Feb(ruary)?))|(29(?=\ Feb(ruary)?\s*(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8]),[\s]*((1[6-9]|[2-9]\d)\d{2})(?=(\W|$))/g },
    { tag: TokenTag.DATE3,
        type: TokenType.DATE3,
        pattern: /(?<=^|\W)(Jan(.|(uary))?|Feb(.|(ruary))?|Ma(r(.|(ch))?|y)|Apr(.|(il))?|Jul(.|(y))?|Jun(.|(e))?|Aug(.|(ust))?|Oct(.|(ober))?|(Sep(?=\b|t)t?|Nov|Dec)(.|(ember))?)\ ((31(?!\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\b|t)t?|Nov)(ember)?)))|((30|29)(?!\ Feb(ruary)?))|(29(?=\ Feb(ruary)?\s*(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])(?=\s)/g },
    { tag: TokenTag.CONTRACTION,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\s|^$)([A-Za-z]+)\'d(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.CONTRACTION,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\s|^$)([A-Za-z]+)\'ll(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.CONTRACTION,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\s|^$)I\'m(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.CONTRACTION,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\W|^$)(([Yy]ou|[Ww]e|[Tt]hey|[Ww]hat)\'re)(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.CONTRACTION,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\W|^$)([Ii]s|[Aa]re|[Ww]as|[Ww]ere|[Hh]ave|[Hh]as|[Hh]ad|[Ww]o|[Ww]ould|[Dd]o|[Dd]oes|[Dd]id|[Cc]a|[Cc]ould|[Ss]hould|[Mm]igh|[Mm]ust])n\'t(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.CONTRACTION,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\s|^$)([A-Za-z]+)\'s(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.CONTRACTION,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\s|^$)(I|[Yy]ou|[Ww]e|[Tt]hey|[Ss]hould|[Cc]ould|[Ww]ould|[Mm]ight|[Mm]ust)\'ve(?=\s|\W|$|[.!?\\-])/g },
    { tag: TokenTag.NUMBER_WITHCOMMAS,
        type: TokenType.CONTRACTION,
        pattern: /(?<=^|\s|^$)(\d{0,3},)?(\d{3},)*(\d{1,3},\d{3})(?=\s|\W|$|[.!?\\-])/g }
    // scan for token that require potential markup tags
];
function isValidMarkupTag(tag) {
    return ((tag.length > 2) && (tag.slice(0, 1) === TokenTag.LANGLEBRACKET)
        && (tag.slice(-1) === TokenTag.RANGLEBRACKET));
}
;
function endMarkupTag(tag) {
    let retValue = null;
    if (isValidMarkupTag(tag)) {
        retValue = tag.slice(0, 1) + "/" + tag.slice(1);
    }
    return retValue;
}
module.exports = { TokenType, endMarkupTag, TokenTag };
