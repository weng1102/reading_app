diff --git a/reading_fe_app/src/pageContext.ts b/reading_fe_app/src/pageContext.ts
index e40fcbb..d092f64 100644
--- a/reading_fe_app/src/pageContext.ts
+++ b/reading_fe_app/src/pageContext.ts
@@ -12,7 +12,6 @@
  **/
 import React from "react"; // define glocal var
 //import { ITerminalInfo, ITerminalInfoInitializer, IPageContent } from "../../src/pageContentType";
-import { useState } from "react"; // define global var
 import {
   IHeadingListItem,
   ILinkListItem,
diff --git a/reading_fe_app/src/reactcomp_config.tsx b/reading_fe_app/src/reactcomp_config.tsx
index 996dfe4..77578a2 100644
--- a/reading_fe_app/src/reactcomp_config.tsx
+++ b/reading_fe_app/src/reactcomp_config.tsx
@@ -27,7 +27,7 @@ interface IConfigSettingsProps {
   active: boolean;
 }
 export const ConfigSettings = (props: IConfigSettingsProps) => {
-  const [distDir, _setDistDir] = useState(props.configSettings.distDir);
+  const [, _setDistDir] = useState(props.configSettings.distDir);
   const setDistDir = (distDir: string) => {
     _setDistDir(distDir);
     props.setConfigSettings({
@@ -38,7 +38,7 @@ export const ConfigSettings = (props: IConfigSettingsProps) => {
   const onDistDirChangeValue = (event: any) => {
     setDistDir(event.target.value);
   };
-  const [homePage, _setHomePage] = useState(props.configSettings.homePage);
+  const [, _setHomePage] = useState(props.configSettings.homePage);
   const setHomePage = (homePage: string) => {
     _setHomePage(homePage);
     props.setConfigSettings({
diff --git a/reading_fe_app/src/reactcomp_listen.tsx b/reading_fe_app/src/reactcomp_listen.tsx
index 4c7e55d..e2f7ffa 100644
--- a/reading_fe_app/src/reactcomp_listen.tsx
+++ b/reading_fe_app/src/reactcomp_listen.tsx
@@ -1,16 +1,20 @@
-//import React from "react";
+/** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
+ *
+ * File name: reactcomp_listen.tsx
+ *
+ * Defines React front end functional components for listening.
+ *
+ *
+ * Version history:
+ *
+ **/
 import "./App.css";
-// import mic_listening from "./mic1-xparent.gif";
-// import mic_notlistening from "./mic1-inactive-xparent.gif";
-// import mic_unavailable from "./mic1-ghosted.gif";
-// import listenGreenActiveIcon from "./button_listen_activeGreen.gif";
-import { StatusBarMessageType } from "./reducers";
-import listenRedActiveIcon from "./button_listen_activeRed.gif";
-import listenIcon from "./button_listen.png";
-import listenGhostedIcon from "./button_listen_ghosted.png";
+import listenRedActiveIcon from "./img/button_listen_activeRed.gif";
+import listenIcon from "./img/button_listen.png";
+import listenGhostedIcon from "./img/button_listen_ghosted.png";
 import { Request } from "./reducers";
 import { useAppDispatch, useAppSelector } from "./hooks";
-import { useEffect, useState, useContext } from "react";
+import { useEffect, useRef, useState, useContext } from "react";
 import SpeechRecognition, {
   useSpeechRecognition
 } from "react-speech-recognition";
@@ -22,35 +26,57 @@ import {
 } from "./settingsContext";
 
 export const ListeningMonitor = () => {
+  console.log = function() {}; // disable console logging
   const [wordsPreviouslyHeard, setWordsPreviouslyHeard] = useState("");
-  const [deferredDispatchStartTime, setDeferredDispatchStartTime] = useState(0);
-  const [silenceCheckpoint, setSilenceCheckpoint] = useState(0);
   const dispatch = useAppDispatch();
   const listeningRequested: boolean = useAppSelector(
     store => store.listen_active
   );
-  const endOfPageReached: boolean = useAppSelector(
-    store => store.cursor_endOfPageReached
-  );
-  // const test: boolean = useAppSelector(store => store.test);
-  const exceededRetries: boolean = useAppSelector(
-    store => store.listen_retriesExceeded
-  );
-  const newSentence: boolean = useAppSelector(
-    store => store.cursor_newSentenceTransition
-  );
-  const flushRequested: boolean = useAppSelector(store => store.listen_flush);
-  // const wordRecited: boolean = useAppSelector(
-  //   store => store.recite_word_requested
-  // );
+
   let settingsContext: ISettingsContext = useContext(
     SettingsContext
   ) as ISettingsContext;
   const silenceTimeout: number = settingsContext.settings.listen.timeout;
-  let queuingDuration: number =
-    settingsContext.settings.listen.listeningInterval;
-  //  const retries: number = useAppSelector(store => store.listen_retries);
+  // let queuingDuration: number =
+  //   settingsContext.settings.listen.listeningInterval;
+  const retries: number = useAppSelector(store => store.listen_retries);
 
+  interface IRecognitionArguments {
+    continuous: boolean;
+    language: string;
+  }
+  const ContinuousListeningForEnglish: IRecognitionArguments = {
+    continuous: true,
+    language: "en-US"
+  };
+  const [silenceTimerId, setSilenceTimerId] = useState<
+    ReturnType<typeof setTimeout>
+  >();
+  // useRef to retrieve the current value of state variable when the function
+  // is invoked and not when it is scheduled
+  const silenceTimerIdRef = useRef(silenceTimerId);
+  const startSilenceTimer = (): ReturnType<typeof setTimeout> => {
+    if (silenceTimerId !== undefined) {
+      clearTimeout(silenceTimerId);
+      console.log(`clearing previous silence timer for id=${silenceTimerId}`);
+    }
+    let retval = setTimeout(() => {
+      console.log(`SILENCE TIMEOUT TRIGGERED`);
+      // in this case same as stopListening() since not speech processing
+      // and Recognition_stop would eventually terminate listening
+      SpeechRecognition.abortListening();
+      dispatch(Request.Recognition_stop());
+    }, silenceTimeout * 1000);
+    console.log(`Starting silence timer for id=${retval}`);
+    setSilenceTimerId(retval);
+    return retval;
+  };
+  const clearSilenceTimer = () => {
+    if (silenceTimerIdRef.current !== undefined) {
+      console.log(`clearing silence timer id=${silenceTimerIdRef.current}`);
+      clearTimeout(silenceTimerIdRef.current);
+    }
+  };
   const {
     transcript,
     interimTranscript,
@@ -59,174 +85,106 @@ export const ListeningMonitor = () => {
     listening
   } = useSpeechRecognition();
 
+  ////////////////////////////////////
   // Start and stop listening manually
-  // useEffect(() => {
-  //   if (endOfPageReached) {
-  //     console.log("stopped listening at end of page");
-  //     dispatch(Request.Recognition_stop());
-  //   }
-  // }, [endOfPageReached]);
-  // useEffect(() => {
-  //   console.log(`reactcomp_listen: test 1=${test}`);
-  //   dispatch(Request.Test_set());
-  //   dispatch(Request.Test_reset());
-  // }, [test]);
-  // useEffect(() => {
-  //   console.log(`reactcomp_listen: test 2=${test}`);
-  //   dispatch(Request.Test_reset());
-  // }, [test]);
-  // useEffect(() => {
-  //   console.log(`reactcomp_listen: test 3=${test}`);
-  //   dispatch(Request.Test_reset());
-  // }, [test]);
-  // useEffect(() => {
-  //   console.log(`LISTENING: ${retries} retries`);
-  //   if (
-  //     settingsContext.settings.listen.retries > 0 &&
-  //     retries > settingsContext.settings.listen.retries
-  //   ) {
-  //     // dispatch(Request.Recognition_setMaxRetriesExceeded());
-  //     console.log(`LISTENING: Exceeded ${retries} retries, goto next word`);
-  //   }
-  // }, [retries]);
-
-  //////////////////////////////
-  // useEffect(() => {
-  //   const maxRetries: number = settingsContext.settings.listen.retries;
-  //   //    const idx: number = useAppSelector(store => store.cursor_terminalIdx);
-  //   if (exceededRetries) {
-  //     console.log(`LISTENING: Exceeded ${maxRetries} retries, next word`);
-  //     // get current word; say the word
-  //     dispatch(Request.Recite_currentWord());
-  //     //      dispatch(Request.Cursor_gotoNextWord());
-  //   }
-  // }, [exceededRetries]);
-  // useEffect(() => {
-  //   if (exceededRetries && reciteWordRequested) {
-  //     dispatch(Request.Cursor_gotoNextWord());
-  //   }
-  // }, wordRrecited]);
+  ////////////////////////////////////
   useEffect(() => {
-    if (endOfPageReached) {
-      console.log("LISTENING: stopped listening at end of page");
-      dispatch(Request.Recognition_stop());
+    if (!listening && listeningRequested) {
+      console.log(`restart listening because browser eventually times out`);
+      SpeechRecognition.startListening(ContinuousListeningForEnglish);
     }
-  }, [listening, endOfPageReached]);
-  // useEffect(() => {
-  //   if (!listeningRequested) {
-  //     dispatch(Request.Recognition_stop());
-  //     console.log("LISTENING: stop listening requested");
-  //   }
-  // }, [listening, listeningRequested]);
-  // useEffect(() => {
-  //   if (!listeningRequested) {
-  //     dispatch(Request.Recognition_stop());
-  //     console.log("LISTENING: stop listening requested");
-  //   }
-  // }, [listening, listeningRequested]);
+  }, [listening, listeningRequested]);
   useEffect(() => {
-    // start listening, listen and stop listening
-    if (listening) {
-      if (!listeningRequested) {
-        dispatch(Request.Recognition_stop());
-        console.log("LISTENING: stop listening requested");
-      }
-    } else if (listeningRequested) {
-      // KLUDGE BECAUSE REDUCER NEEDS INITIAL RETRIES. Subsequent changes
-      // retries managed within setting dialog
+    if (!listeningRequested) {
+      dispatch(Request.Recognition_stop());
+      SpeechRecognition.abortListening();
+      clearSilenceTimer();
+      console.log("LISTENING: stop listening requested");
+    } else {
+      // timeout periodically not
+      SpeechRecognition.startListening(ContinuousListeningForEnglish);
+
+      console.log(`LISTENING: start listening with timeout=${silenceTimeout}s`);
+      startSilenceTimer();
       console.log(
-        `LISTENING: start listening with timeout=${silenceTimeout}s and buffering time=${queuingDuration}ms`
+        `initial setSilenceTimer for id=${silenceTimerIdRef.current}`
       );
-      if (silenceCheckpoint === 0) {
-        setSilenceCheckpoint(Date.now()); // will only works continuuous=false
-        console.log(`LISTENING: set silence checkpoint=${silenceCheckpoint}`);
-      }
-      if (deferredDispatchStartTime === 0) {
-        setDeferredDispatchStartTime(Date.now());
-      }
-      SpeechRecognition.startListening(); // timeout periodically not continuous: true
-    } else {
-      console.log("LISTENING: continue not listening");
-      SpeechRecognition.abortListening(); //just in case
-      console.log(`LISTENING: reset silence checkpoint`);
-      setSilenceCheckpoint(0);
     }
-  }, [
-    listening,
-    listeningRequested,
-    deferredDispatchStartTime,
-    silenceCheckpoint,
-    setSilenceCheckpoint
-  ]);
+  }, [listeningRequested]);
+
   useEffect(() => {
-    // listening
-    // must have [listening] as dependency to allow effect to periodically
-    // trigger based on SpeechRecognition internal trigger.
     let words: string;
-    if (finalTranscript !== "") {
-      console.log(`LISTENING: final transcript=${finalTranscript} `);
-      words = finalTranscript;
-      resetTranscript();
+    if (!listening) {
+      // console.log(`LISTENING: No longer listening...`);
+      if (listeningRequested) {
+        // speech recognition timed out
+        // console.log(`NO LONGER LISTENING...BUT LISTENING RESTARTED`);
+        SpeechRecognition.startListening(ContinuousListeningForEnglish); // timeout periodically not
+      }
     } else {
-      words = interimTranscript;
+      // console.log(`LISTENING...`);
     }
-    // defer dispatch(CursorActions.matchWord()) to allow speechrecognition to
-    // gather additional context. The SpeechRecogition object only triggers
-    // (asynchronously) when it detects speech (and when it detects silence
-    // for several seconds). This effect must balance this deferment with
-    // the component updating the current word recited.
-    if (words.length === 0 || words === wordsPreviouslyHeard) {
-      let timeoutDuration = Math.round((Date.now() - silenceCheckpoint) / 1000);
-      console.log(`LISTENING: timeout in ${silenceTimeout - timeoutDuration}s`);
-      if (timeoutDuration > silenceTimeout) {
-        dispatch(Request.Recognition_stop());
-        setWordsPreviouslyHeard("");
-      } else if (words === wordsPreviouslyHeard) {
-        console.log(`LISTENING: heard nothing new "${words}"`);
+    {
+      if (finalTranscript !== "") {
+        console.log(`final=  ${finalTranscript}`);
+        words = finalTranscript;
+        resetTranscript();
+      } else {
+        words = interimTranscript;
+        console.log(`interim=${interimTranscript}`);
       }
-    } else {
-      setWordsPreviouslyHeard(words);
-      setSilenceCheckpoint(Date.now());
-      const msecBeforeDispatch = queuingDuration; //msec
-      let deferredDispatchWaitDuration = Date.now() - deferredDispatchStartTime;
-      if (deferredDispatchWaitDuration > msecBeforeDispatch) {
-        console.log(
-          `LISTENING: matchWords(${words}]) dispatched timeout after ${deferredDispatchWaitDuration -
-            msecBeforeDispatch}ms remaining`
-        );
-        dispatch(Request.Cursor_matchWords(words));
-        setDeferredDispatchStartTime(Date.now());
-        // NOTE: only reset transcript at the end of sentence!
+      console.log(`heard=  ${words}`);
+      // words === wordsPreviouslyHeard) {
+      // need to skip matching if nothing new is recognized. Remember, the
+      // SpeechRecognition engine continues to guess at what was said even
+      // though the speaker hasn't uttered another word. This check is
+      // primarily to try and reduce inadvertant retry increment...
+      // but its not very effective because the engine typically returns
+      // different interpretations of what it heard.
+      // Also, previously heard words should only be compared to words NOT
+      // silence (blanks)
+      if (words.length === 0) {
+        console.log(`detecting silence`);
+      } else if (wordsPreviouslyHeard.includes(words)) {
+        console.log(`detecting only previous words`);
       } else {
-        console.log(
-          `LISTENING: deferring dispatch for interimTranscript=${words}`
-        );
+        //        setWordsPreviouslyHeard(words);
+        startSilenceTimer();
+        dispatch(Request.Cursor_matchWords(words));
+
+        // in the future, the actual word matching can be brought into this
+        // component and just sent dispatch Cursor_gotoNextWord() and
+        // retriesExceeded.
+        // clean up timer to prevent weird behavior and memory leaks
       }
     }
+    return () => {
+      clearTimeout(silenceTimerIdRef.current!);
+    };
   }, [
-    listening,
-    deferredDispatchStartTime,
-    setDeferredDispatchStartTime,
-    silenceCheckpoint,
-    setSilenceCheckpoint,
+    listening, // will be false when user manually aborts speech
+    listeningRequested, // required to stop SpeechRecognition from listening
+    transcript,
     interimTranscript,
     finalTranscript,
     resetTranscript
   ]);
+  const retriesExceeded = useAppSelector(store => store.listen_retriesExceeded);
+  const reciteWordRequested = useAppSelector(
+    store => store.recite_word_requested
+  );
   useEffect(() => {
-    if (newSentence) {
-      console.log(`LISTENING: new sentence transition`);
-      dispatch(Request.Recognition_flush());
-      // dispatch(
-      //   Request.Message_set(
-      //     "new sentence transition",
-      //     StatusBarMessageType.listening
-      //   )
-      // );
-      // } else {
-      //   dispatch(Request.Message_clear(StatusBarMessageType.listening));
+    console.log(`LISTENING: retries exceeded; reset transcript`);
+    if (retriesExceeded) {
+      if (!reciteWordRequested) {
+        resetTranscript();
+        dispatch(Request.Recite_currentWord());
+      } else {
+        dispatch(Request.Cursor_gotoNextWord());
+      }
     }
-  }, [newSentence]);
+  }, [retriesExceeded, reciteWordRequested]);
+  const flushRequested: boolean = useAppSelector(store => store.listen_flush);
   useEffect(() => {
     if (flushRequested) {
       console.log(`LISTENING: flushing transcript queue`);
@@ -236,11 +194,34 @@ export const ListeningMonitor = () => {
     }
   }, [flushRequested]);
 
+  ///////////////////////
+  // Transition callbacks
+  ///////////////////////
+  const newSentence: boolean = useAppSelector(
+    store => store.cursor_newSentenceTransition
+  );
+  useEffect(() => {
+    if (newSentence) {
+      console.log(`LISTENING: new sentence transition`);
+      dispatch(Request.Recognition_flush());
+    }
+  }, [newSentence]);
   const message_listen: string = useAppSelector(
     store => store.message_listening
   );
+  const endOfPageReached: boolean = useAppSelector(
+    store => store.cursor_endOfPageReached
+  );
+  useEffect(() => {
+    if (endOfPageReached) {
+      console.log("LISTENING: stopped listening at end of page");
+      dispatch(Request.Recognition_stop());
+    }
+  }, [listening, endOfPageReached]);
+
   if (SpeechRecognition.browserSupportsSpeechRecognition()) {
-    // listenButton disallows already
+    // listenButton disallows listening already but just in case
+
     return <div className="footer-statusBar">{message_listen}</div>;
   } else {
     return (
@@ -309,10 +290,6 @@ export const ListenSettings = (props: IListenSettingsProps) => {
         <Retries retries={retries} setRetries={setRetries} />
         <StopAtEOS stopAtEOS={stopAtEOS} setStopAtEOS={setStopAtEOS} />
         <Timeout timeout={timeout} setTimeout={setTimeout} />
-        <ListeningInterval
-          listeningInterval={listeningInterval}
-          setListeningInterval={setListeningInterval}
-        />
         <NotificationModeRadioButton
           notificationMode={notificationMode}
           setNotificationMode={setNotificationMode}
diff --git a/reading_fe_app/src/reactcomp_navbar.tsx b/reading_fe_app/src/reactcomp_navbar.tsx
index deb9cb2..a71087c 100644
--- a/reading_fe_app/src/reactcomp_navbar.tsx
+++ b/reading_fe_app/src/reactcomp_navbar.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_navbar.tsx
+ * File name: reactcomp_navbar.tsx
  *
  * Defines React front end functional component for navbar.
  *
diff --git a/reading_fe_app/src/reactcomp_page.tsx b/reading_fe_app/src/reactcomp_page.tsx
index 2b042de..c12c67c 100644
--- a/reading_fe_app/src/reactcomp_page.tsx
+++ b/reading_fe_app/src/reactcomp_page.tsx
@@ -47,7 +47,7 @@ import { PageHeader } from "./reactcomp_pageheader";
 import { PageFooter } from "./reactcomp_pagefooter";
 import { SettingsDialog } from "./reactcomp_settings";
 import { SectionDispatcher } from "./reactcomp_sections";
-import { StatusBarMessageType } from "./reducers";
+// import { StatusBarMessageType } from "./reducers";
 
 interface IPreviousPageArrayItem {
   page: string;
@@ -151,15 +151,15 @@ export const Page = React.memo((props: IPagePropsType) => {
   const pageLoaded: boolean = useAppSelector(store => store.page_loaded);
   let message: string = "";
   useEffect(() => {
-    message = `Requested page ${pageRequested} from ${distDir}`;
-    console.log(message);
+    // message = `Requested page ${pageRequested} from ${distDir}`;
+    // console.log(message);
     setIsPageLoaded(
       !(pageRequested !== undefined && pageRequested !== null && !pageLoaded)
     );
     fetchRequest(distDir + pageRequested + ".json");
     //    dispatch(Request.Message_set(message, StatusBarMessageType.application));
     // }
-  }, [pageRequested, pageLoaded]);
+  }, [distDir, pageRequested, pageLoaded]);
   useEffect(() => {
     if (!isPageLoaded) {
       dispatch(Request.Page_loaded(true));
@@ -169,7 +169,7 @@ export const Page = React.memo((props: IPagePropsType) => {
         currentTermIdx: 0
       });
       setPreviousPages(previousPages);
-      console.log(previousPages);
+      console.log(`previousPage Stack ${previousPages}`);
       // if requested page is home page then clear stack!
     }
   }, [pageContent, pageContext]);
@@ -229,9 +229,6 @@ export const Page = React.memo((props: IPagePropsType) => {
       </PageContext.Provider>
     );
   } else {
-    // no statusbar until pageLoaded
-    //  message = `Waiting to load "${pageRequested}"`;
-    console.log(message);
     return <div className="loadingAnnouncement">{message}</div>;
   }
 });
diff --git a/reading_fe_app/src/reactcomp_pagefooter.tsx b/reading_fe_app/src/reactcomp_pagefooter.tsx
index 81226a8..dcc3939 100644
--- a/reading_fe_app/src/reactcomp_pagefooter.tsx
+++ b/reading_fe_app/src/reactcomp_pagefooter.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_footer.tsx
+ * File name: reactcomp_footer.tsx
  *
  * Defines React front end functional components.
  *
@@ -19,20 +19,17 @@ import { SpeechMonitor } from "./reactcomp_speech";
 import { ReciteButton } from "./reactcomp_speech_recite";
 //import { SpeakButton } from "./reactcomp_speech_speakbutton";
 import { ListenButton, ListeningMonitor } from "./reactcomp_listen";
-import nextwordIcon from "./button_nextword.png";
-import prevwordIcon from "./button_prevword.png";
-import prevsentenceIcon from "./button_prevsentence.png";
-import nextsentenceIcon from "./button_nextsentence.png";
-import nextwordGhostedIcon from "./button_nextword_ghosted.png";
-import prevwordGhostedIcon from "./button_prevword_ghosted.png";
-import prevsentenceGhostedIcon from "./button_prevsentence_ghosted.png";
-import nextsentenceGhostedIcon from "./button_nextsentence_ghosted.png";
-import gotoLinkIcon from "./button_link.png";
-import gotoLinkGhostedIcon from "./button_link_ghosted.png";
+import nextwordIcon from "./img/button_nextword.png";
+import prevwordIcon from "./img/button_prevword.png";
+import prevsentenceIcon from "./img/button_prevsentence.png";
+import nextsentenceIcon from "./img/button_nextsentence.png";
+import nextwordGhostedIcon from "./img/button_nextword_ghosted.png";
+import prevwordGhostedIcon from "./img/button_prevword_ghosted.png";
+import prevsentenceGhostedIcon from "./img/button_prevsentence_ghosted.png";
+import nextsentenceGhostedIcon from "./img/button_nextsentence_ghosted.png";
+import gotoLinkIcon from "./img/button_link.png";
+import gotoLinkGhostedIcon from "./img/button_link_ghosted.png";
 
-interface IPageFooterPropsType {
-  title: string;
-}
 export const PageFooter = React.memo(() => {
   // retrieve pageContext
   console.log(`<PageFooter>`);
@@ -215,7 +212,6 @@ export const LinkButton = () => {
     </>
   );
 };
-interface StatusBarPropsType {}
 export const StatusBar = () => {
   return (
     <>
diff --git a/reading_fe_app/src/reactcomp_pageheader.tsx b/reading_fe_app/src/reactcomp_pageheader.tsx
index 57ec6fd..7d61218 100644
--- a/reading_fe_app/src/reactcomp_pageheader.tsx
+++ b/reading_fe_app/src/reactcomp_pageheader.tsx
@@ -10,45 +10,23 @@
  **/
 import React from "react";
 import "./App.css";
-import hamburgerIcon from "./Hamburger_icon.png";
-import settingsIcon from "./settingicon.png";
-import homePageIcon from "./button_homeicon.png";
-import siteMapIcon from "./button_sitemap.png";
-import PrevPageIcon from "./button_back.png";
-import { SettingsDialog, SettingsButton } from "./reactcomp_settings";
+import hamburgerIcon from "./img/Hamburger_icon.png";
+import settingsIcon from "./img/settingicon.png";
+import homePageIcon from "./img/button_homeicon.png";
+import siteMapIcon from "./img/button_sitemap.png";
+import PrevPageIcon from "./img/button_back.png";
+import { SettingsDialog } from "./reactcomp_settings";
 
-// import mic_listening from "./mic1-xparent.gif";
-// import mic_notlistening from "./mic1-inactive-xparent.gif";
-// import mic_unavailable from "./mic1-ghosted.gif";
 import { Request } from "./reducers";
-import { useAppDispatch, useAppSelector, useDialog } from "./hooks";
-import { useEffect, useState, useContext } from "react";
+import { useAppDispatch, useDialog } from "./hooks";
+import { useContext } from "react";
 
-// is this really necessary if availablility is removed below
-import SpeechRecognition, {
-  useSpeechRecognition
-} from "react-speech-recognition";
-import {
-  IPageContent,
-  IHeadingListItem,
-  ISectionContent,
-  ISentenceContent,
-  ITerminalContent,
-  ITerminalInfo,
-  IAcronymTerminalMeta,
-  IWordTerminalMeta,
-  TerminalMetaEnumType,
-  SectionVariantEnumType,
-  ISectionParagraphVariant
-} from "./pageContentType";
-
-import { ISettingsContext, SettingsContext } from "./settingsContext";
+import { SettingsContext } from "./settingsContext";
 
 interface IPageHeaderPropsType {
   title: string;
 }
 export const PageHeader = React.memo((props: IPageHeaderPropsType) => {
-  const dispatch = useAppDispatch();
   const { isActive, toggleDialog } = useDialog();
   console.log(`<PageHeader>`);
   return (
diff --git a/reading_fe_app/src/reactcomp_sections.tsx b/reading_fe_app/src/reactcomp_sections.tsx
index 98ab279..3626fa5 100644
--- a/reading_fe_app/src/reactcomp_sections.tsx
+++ b/reading_fe_app/src/reactcomp_sections.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_sections.tsx
+ * File name: reactcomp_sections.tsx
  *
  * Defines React front end functional components.
  *
@@ -15,10 +15,8 @@ import {
   ISectionContent,
   ISentenceContent,
   ISectionHeadingVariant,
-  ISectionHeadingVariant1,
   SectionVariantEnumType,
-  ISectionParagraphVariant,
-  ISectionUnorderedListVariant
+  ISectionParagraphVariant
 } from "./pageContentType";
 import { Section_imageEntry } from "./reactcomp_sections_imageEntry";
 //import { Settings } from "./reactcomp_settings";
diff --git a/reading_fe_app/src/reactcomp_sections_imageEntry.tsx b/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
index 74a3449..9b6c7bd 100644
--- a/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
+++ b/reading_fe_app/src/reactcomp_sections_imageEntry.tsx
@@ -10,17 +10,11 @@
  **/
 import React from "react";
 import "./App.css";
-import { useAppSelector, useDivRef } from "./hooks";
 import {
   ImageEntryLayoutEnumType,
   ISectionContent,
-  ISentenceContent,
   ISectionImageEntryVariant,
-  SectionVariantEnumType,
-  ISectionParagraphVariant,
-  ISectionUnorderedListVariant,
   ITerminalContent,
-  ITerminalInfo,
   IImageTerminalMeta
 } from "./pageContentType";
 import { Terminal_Image } from "./reactcomp_terminals_image";
diff --git a/reading_fe_app/src/reactcomp_sentences.tsx b/reading_fe_app/src/reactcomp_sentences.tsx
index ee1cc70..d457b72 100644
--- a/reading_fe_app/src/reactcomp_sentences.tsx
+++ b/reading_fe_app/src/reactcomp_sentences.tsx
@@ -1,6 +1,6 @@
-/** Copyright (C) 2020 - 2021 Wen Eng - All Rights Reserved
+/** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_sentences.tsx
+ * File name: reactcomp_sentences.tsx
  *
  * Defines React front end functional components.
  *
@@ -10,21 +10,10 @@
  **/
 import React from "react";
 import "./App.css";
-import { useAppDispatch, useAppSelector, useSpanRef, useDivRef } from "./hooks";
-
-// is this really necessary if availablility is removed below
-import SpeechRecognition, {
-  useSpeechRecognition
-} from "react-speech-recognition";
 
 import { ISentenceContent, ITerminalContent } from "./pageContentType";
 import { TerminalDispatcher } from "./reactcomp_terminals";
 
-const SectionType = {
-  ORDEREDLIST: "ol",
-  UNORDEREDLIST: "ul",
-  PARAGRAPH: "none"
-};
 export interface ISentencePropsType {
   //  key: number;
   active: boolean;
diff --git a/reading_fe_app/src/reactcomp_settings.tsx b/reading_fe_app/src/reactcomp_settings.tsx
index 612aba2..51f9a52 100644
--- a/reading_fe_app/src/reactcomp_settings.tsx
+++ b/reading_fe_app/src/reactcomp_settings.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_settings.tsx
+ * File name: reactcomp_settings.tsx
  *
  * Defines React front end functional components popup settings modal
  * page
@@ -22,11 +22,10 @@
 import { useContext, useState } from "react";
 import { useAppDispatch } from "./hooks";
 import { Request } from "./reducers";
-import settingsIcon from "./settingicon.png";
-import OkIcon from "./button_OK.png";
-import OkIcon_ghosted from "./button_OK_ghosted.png";
-import CancelIcon from "./button_cancel.png";
-//import CancelIcon_ghosted from "./button_cancel_ghosted.png"
+import settingsIcon from "./img/settingicon.png";
+import OkIcon from "./img/button_OK.png";
+import OkIcon_ghosted from "./img/button_OK_ghosted.png";
+import CancelIcon from "./img/button_cancel.png";
 import { ConfigSettings } from "./reactcomp_config";
 import { SpeechSettings } from "./reactcomp_speech";
 import { ListenSettings } from "./reactcomp_listen";
@@ -112,15 +111,6 @@ export const SettingsDialog = (props: ISettingsDialogPropsType) => {
     props.hide();
     dispatch(Request.Test_set());
   };
-  const markersInactive: string[] = ["", "", "", "", ""];
-  let tabMarkers: string[] = markersInactive;
-  const clickTab = (tab: number) => {
-    tabMarkers = markersInactive;
-    setActiveTab(tab);
-    console.log(`tab ${tab} selected`);
-    if (tab > 0 && tab < tabMarkers.length) tabMarkers[tab] = "active";
-  };
-
   let OkIcons = modified ? OkIcon : OkIcon_ghosted;
   let dispatch = useAppDispatch();
   // could do deep compare between temp and current contexts
diff --git a/reading_fe_app/src/reactcomp_speech.tsx b/reading_fe_app/src/reactcomp_speech.tsx
index e396a19..95d71a1 100644
--- a/reading_fe_app/src/reactcomp_speech.tsx
+++ b/reading_fe_app/src/reactcomp_speech.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_speech.tsx
+ * File name: reactcomp_speech.tsx
  *
  * Defines React front end functional components.
  *
@@ -14,8 +14,7 @@
  *
  **/
 //import "./App.css";
-import { Request } from "./reducers";
-import { useAppDispatch, useAppSelector } from "./hooks";
+import { useAppSelector } from "./hooks";
 import { useEffect, useState, useContext } from "react";
 import { CPageLists } from "./pageContext";
 import {
@@ -24,9 +23,6 @@ import {
   RecitationMode,
   SettingsContext
 } from "./settingsContext";
-import speakGhostedIcon from "./button_speak_ghosted.png";
-import speakActiveIcon from "./button_speak_activeRed.gif";
-import speakInactiveIcon from "./button_speak.png";
 
 class CSpeechSynthesizer {
   constructor() {
@@ -69,7 +65,6 @@ export const SpeechMonitor = () => {
     false
   );
   const [announce_newSection, setAnnounce_newSection] = useState(false);
-  const [announce_endOfPage, setAnnounce_endOfPage] = useState(false);
   const resetAnnounce_transitions = () => {
     setAnnounce_beginningOfPage(false);
     setAnnounce_newSection(false);
@@ -118,7 +113,13 @@ export const SpeechMonitor = () => {
       Synthesizer.speak(message);
     }
     resetAnnounce_transitions();
-  }, [announce_beginningOfPage, announce_newSection, announce_newSentence]);
+  }, [
+    announce_beginningOfPage,
+    announce_newSection,
+    announce_newSentence,
+    pageContext.sectionList,
+    sectionIdx
+  ]);
   // useEffect(() => {
   //   if (pageLoaded) {
   //     message = "page loaded";
@@ -521,8 +522,7 @@ interface IVoiceSelectorProps {
   setVoiceIndex: (voice: number) => void;
 }
 const VoiceSelector = (props: IVoiceSelectorProps) => {
-  const [selectedOption, setSelectedOption] = useState("");
-  const [voicesAvailable, setVoicesAvailable] = useState(false);
+  const [, setVoicesAvailable] = useState(false);
   useEffect(() => {
     setVoicesAvailable(true); // force rerender of component
   }, [window.speechSynthesis.onvoiceschanged]);
diff --git a/reading_fe_app/src/reactcomp_speech_recite.tsx b/reading_fe_app/src/reactcomp_speech_recite.tsx
index 99bd77a..ccc4c2e 100644
--- a/reading_fe_app/src/reactcomp_speech_recite.tsx
+++ b/reading_fe_app/src/reactcomp_speech_recite.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_speech_speakbutton.tsx
+ * File name: reactcomp_speech_speakbutton.tsx
  *
  * Defines React front end speak button functional component.
  *
@@ -10,12 +10,12 @@
  *
  **/
 import { Request } from "./reducers";
-import speakGhostedIcon from "./button_speak_ghosted.png";
-import speakActiveIcon from "./button_speak_activeRed.gif";
-import speakInactiveIcon from "./button_speak.png";
+import speakGhostedIcon from "./img/button_speak_ghosted.png";
+import speakActiveIcon from "./img/button_speak_activeRed.gif";
+import speakInactiveIcon from "./img/button_speak.png";
 import { useAppDispatch, useAppSelector } from "./hooks";
 import { useEffect, useState, useContext } from "react";
-import { CPageLists, PageContext } from "./pageContext";
+import { CPageLists } from "./pageContext";
 import {
   ISettingsContext,
   RecitationMode,
@@ -139,31 +139,17 @@ export const ReciteButton = () => {
     }
     return messageQueue;
   };
-
-  const retriesExceeded = useAppSelector(store => store.listen_retriesExceeded);
+  const reciteWordRequested = useAppSelector(
+    store => store.recite_word_requested
+  );
   useEffect(() => {
-    const maxRetries: number = settingsContext.settings.listen.retries;
-    //    const idx: number = useAppSelector(store => store.cursor_terminalIdx);
-    if (retriesExceeded) {
-      console.log(`LISTENING: Exceeded ${maxRetries} retries, next word`);
-      // get current word; say the word
+    if (reciteWordRequested) {
       Synthesizer.volume = settingsContext.settings.speech.volume;
       Synthesizer.speak(wordToRecite(currentTermIdx)); //synchronous
-      dispatch(Request.Cursor_gotoNextWord());
+      dispatch(Request.Recited_currentWord());
     }
-  }, [retriesExceeded]);
+  }, [reciteWordRequested, currentTermIdx]);
 
-  // const reciteWordRequested = useAppSelector(
-  //   store => store.recite_word_requested
-  // );
-  // useEffect(() => {
-  //   if (reciteWordRequested) {
-  //     Synthesizer.volume = settingsContext.settings.speech.volume;
-  //     Synthesizer.speak(wordToRecite(currentTermIdx)); //synchronous
-  //     dispatch(Request.Recited_currentWord());
-  //     dispatch(Request.Cursor_gotoNextWord());
-  //   }
-  // }, [reciteWordRequested]);
   useEffect(() => {
     // if current word changes, then  stop reciting
     if (reciting) {
@@ -176,7 +162,7 @@ export const ReciteButton = () => {
       console.log(`useEffect[reciting]: ${currentTermIdx}`);
       setRecitationQueue(somethingToRecite(currentTermIdx));
     }
-  }, [reciting]);
+  }, [reciting, currentTermIdx]);
   useEffect(() => {
     // need to chop up the message into at least sentences so cancel
     // (reciting=false) request can can be processed especially for longer
@@ -194,7 +180,7 @@ export const ReciteButton = () => {
     } else {
       // not reciting and not requested
     }
-  }, [reciteRequested]);
+  }, [reciteRequested, reciting, currentTermIdx]);
   useEffect(() => {
     // need to chop up the message so cancel request can can be polled
     // especially for longer passages.
@@ -212,7 +198,13 @@ export const ReciteButton = () => {
         }
       }
     }
-  }, [recitingNow, recitationQueue]);
+  }, [
+    recitingNow,
+    reciting,
+    recitationQueue,
+    recitationMode,
+    settingsContext.settings.speech.volume
+  ]);
   // if currently listening, stop and restart after reciting
   dispatch(Request.Recognition_stop);
   return (
diff --git a/reading_fe_app/src/reactcomp_speech_speakbutton.tsx b/reading_fe_app/src/reactcomp_speech_speakbutton.tsx
index 11a3282..c1f3aa6 100644
--- a/reading_fe_app/src/reactcomp_speech_speakbutton.tsx
+++ b/reading_fe_app/src/reactcomp_speech_speakbutton.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_speech_speakbutton.tsx
+ * File name: reactcomp_speech_speakbutton.tsx
  *
  * Defines React front end speak button functional component.
  *
@@ -10,12 +10,12 @@
  *
  **/
 import { Request } from "./reducers";
-import speakGhostedIcon from "./button_speak_ghosted.png";
-import speakActiveIcon from "./button_speak_activeRed.gif";
-import speakInactiveIcon from "./button_speak.png";
+import speakGhostedIcon from "./img/button_speak_ghosted.png";
+import speakActiveIcon from "./img/button_speak_activeRed.gif";
+import speakInactiveIcon from "./img/button_speak.png";
 import { useAppDispatch, useAppSelector } from "./hooks";
 import { useEffect, useState, useContext } from "react";
-import { CPageLists, PageContext } from "./pageContext";
+import { CPageLists } from "./pageContext";
 import {
   ISettingsContext,
   RecitationMode,
diff --git a/reading_fe_app/src/reactcomp_terminals.tsx b/reading_fe_app/src/reactcomp_terminals.tsx
index 7541046..fac87c0 100644
--- a/reading_fe_app/src/reactcomp_terminals.tsx
+++ b/reading_fe_app/src/reactcomp_terminals.tsx
@@ -1,6 +1,6 @@
 /** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_terminals.tsx
+ * File name: reactcomp_terminals.tsx
  *
  * Defines React front end functional components for terminals.
  *
@@ -74,7 +74,6 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
-        break;
       case TerminalMetaEnumType.word:
       case TerminalMetaEnumType.symbol:
         return (
@@ -85,10 +84,8 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
-        break;
       case TerminalMetaEnumType.whitespace:
         return <Terminal_Whitespace active={false} terminal={props.terminal} />;
-        break;
       case TerminalMetaEnumType.currency:
         break;
       case TerminalMetaEnumType.date:
@@ -101,7 +98,6 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
-        break;
       case TerminalMetaEnumType.emailaddress:
         return (
           <Terminal_Emailaddress
@@ -112,7 +108,6 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
-        break;
       case TerminalMetaEnumType.image:
         //active should be false regardless
         return (
@@ -124,7 +119,6 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
-        break;
       case TerminalMetaEnumType.link:
         return (
           <Terminal_Link
@@ -135,7 +129,6 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
-        break;
       case TerminalMetaEnumType.numberwithcommas:
         break;
       case TerminalMetaEnumType.phonenumber:
@@ -148,10 +141,8 @@ export const TerminalDispatcher = React.memo(
             terminal={props.terminal}
           />
         );
-        break;
       case TerminalMetaEnumType.punctuation:
         return <Terminal_Whitespace active={false} terminal={props.terminal} />;
-        break;
       case TerminalMetaEnumType.tbd:
         break;
       case TerminalMetaEnumType.time:
@@ -162,7 +153,6 @@ export const TerminalDispatcher = React.memo(
         break;
       default:
         return <>unknown terminal "{props.terminal.content}"</>;
-        break;
     }
   }
 );
diff --git a/reading_fe_app/src/reactcomp_terminals_emailaddress.tsx b/reading_fe_app/src/reactcomp_terminals_emailaddress.tsx
index 281519f..a1ee82d 100644
--- a/reading_fe_app/src/reactcomp_terminals_emailaddress.tsx
+++ b/reading_fe_app/src/reactcomp_terminals_emailaddress.tsx
@@ -1,6 +1,6 @@
-/** Copyright (C) 2020 - 2021 Wen Eng - All Rights Reserved
+/** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
- * File name: reactcomps_terminal_emailaddress.tsx
+ * File name: reactcomp_terminal_emailaddress.tsx
  *
  * Defines React front end functional components.
  * renders emailaddress
@@ -10,8 +10,7 @@
  **/
 import React from "react";
 // import "./App.css";
-import { useAppDispatch, useAppSelector, useSpanRef, useDivRef } from "./hooks";
-import { useEffect, useState, useContext, useRef } from "react";
+import { useAppSelector } from "./hooks";
 
 import { ITerminalInfo, IEmailAddressTerminalMeta } from "./pageContentType";
 import { TerminalNode, ITerminalPropsType } from "./reactcomp_terminals";
diff --git a/reading_fe_app/src/reactcomp_terminals_image.tsx b/reading_fe_app/src/reactcomp_terminals_image.tsx
index bfd99d8..4e51f18 100644
--- a/reading_fe_app/src/reactcomp_terminals_image.tsx
+++ b/reading_fe_app/src/reactcomp_terminals_image.tsx
@@ -1,4 +1,4 @@
-/** Copyright (C) 2020 - 2021 Wen Eng - All Rights Reserved
+/** Copyright (C) 2020 - 2022 Wen Eng - All Rights Reserved
  *
  * File name: reactcomps_terminal_image.tsx
  *
@@ -9,13 +9,11 @@
  *
  **/
 import React, { useContext } from "react";
-import { useAppSelector } from "./hooks";
 
-import { ITerminalInfo, IImageTerminalMeta } from "./pageContentType";
-import { TerminalNode, ITerminalPropsType } from "./reactcomp_terminals";
+import { IImageTerminalMeta } from "./pageContentType";
+import { ITerminalPropsType } from "./reactcomp_terminals";
 import { ISettingsContext, SettingsContext } from "./settingsContext";
 export const Terminal_Image = React.memo((props: ITerminalPropsType): any => {
-  const currentTerminalIdx = useAppSelector(store => store.cursor_terminalIdx); // causes rerendering
   let settingsContext: ISettingsContext = useContext(
     SettingsContext
   ) as ISettingsContext;
diff --git a/reading_fe_app/src/reactcomp_terminals_link.tsx b/reading_fe_app/src/reactcomp_terminals_link.tsx
index fdff1eb..69b5029 100644
--- a/reading_fe_app/src/reactcomp_terminals_link.tsx
+++ b/reading_fe_app/src/reactcomp_terminals_link.tsx
@@ -8,9 +8,7 @@
  * Version history:
  *
  **/
-import React, { useContext } from "react";
-import { useAppDispatch, useAppSelector } from "./hooks";
-import { Request } from "./reducers";
+import React from "react";
 import {
   ICurriculumLinkTerminalMeta,
   ITerminalContent
@@ -25,7 +23,6 @@ export const Terminal_Link = React.memo((props: ITerminalPropsType): any => {
   let linkInfo: ICurriculumLinkTerminalMeta = props.terminal
     .meta as ICurriculumLinkTerminalMeta;
 
-  let linkClasses: string = "link-label" + linkInfo.className;
   return (
     <>
       <span className="link-label">
diff --git a/reading_fe_app/src/reducers.ts b/reading_fe_app/src/reducers.ts
index 0b0f260..1190655 100644
--- a/reading_fe_app/src/reducers.ts
+++ b/reading_fe_app/src/reducers.ts
@@ -14,9 +14,7 @@
  * Version history:
  *
  **/
-import { useContext } from "react";
 import { CPageLists } from "./pageContext";
-import { RecitationMode } from "./settingsContext";
 // import {
 //   ISettings,
 //   ISettingsContext,
@@ -28,7 +26,7 @@ export enum StatusBarMessageType {
   state = 2,
   all = 3
 }
-const IDX_INITIALIZER = -9999; // should be same as baseclasses.ts
+//const IDX_INITIALIZER = -9999; // should be same as baseclasses.ts
 
 // word actions
 const WORD_MATCH = "word/match"; // match word with argument with current word
@@ -554,7 +552,8 @@ interface IReduxState {
   page_pop_requested: boolean;
 
   recite_requested: boolean;
-  // recite_word_requested: boolean;
+  recite_word_requested: boolean;
+  recite_word_completed: boolean;
   reciting: boolean;
 
   settings_toggle: boolean;
@@ -600,7 +599,8 @@ const IReduxStateInitialState: IReduxState = {
   pageContext: new CPageLists(),
 
   recite_requested: false,
-  // recite_word_requested: false,
+  recite_word_requested: false,
+  recite_word_completed: true,
   reciting: false,
 
   settings_toggle: false,
@@ -664,21 +664,25 @@ export const rootReducer = (
     }
   };
   const setToNextTerminalState = () => {
+    resetListeningRetries();
     setTerminalState(
       state.pageContext.nextTerminalIdx(state.cursor_terminalIdx)
     );
   };
   const setToPrevTerminalState = () => {
+    resetListeningRetries();
     setTerminalState(
       state.pageContext.previousTerminalIdx(state.cursor_terminalIdx)
     );
   };
   const setToNextSentenceTerminalState = () => {
+    resetListeningRetries();
     setTerminalState([
       state.pageContext.nextSentenceTerminalIdx(state.cursor_terminalIdx)
     ]);
   };
   const setToPrevSentenceTerminalState = () => {
+    resetListeningRetries();
     setTerminalState([
       state.pageContext.previousSentenceTerminalIdx(state.cursor_terminalIdx)
     ]);
@@ -798,20 +802,12 @@ export const rootReducer = (
         state.pageContext !== undefined &&
         state.pageContext !== null
       ) {
-        let expecting: string =
-          state.pageContext.terminalList[state.cursor_terminalIdx].content;
-        let expectingAlt: string =
-          state.pageContext.terminalList[state.cursor_terminalIdx]
-            .altrecognition; // should .split(" ")
-        // setStateMessage(
-        //   `Heard="${wordsHeard}"; Expected "${expecting}" ${
-        //     state.pageContext.terminalList[state.cursor_terminalIdx]
-        //       .altrecognition.length > 0
-        //       ? " or "
-        //       : ""
-        //   } "${expectingAlt}"`
-        // );
-
+        let expecting: string = state.pageContext.terminalList[
+          state.cursor_terminalIdx
+        ].content.toLowerCase();
+        let expectingAlt: string = state.pageContext.terminalList[
+          state.cursor_terminalIdx
+        ].altrecognition.toLowerCase(); // should .split(" ")
         // console.log(state.message_listening);
         // need to handle altRecognition word list against consecutive words heard
         //   1) Lookahead in words heard list to allow a peek.
@@ -822,45 +818,26 @@ export const rootReducer = (
         //      altReg list words heard.)
         if (wordsHeard.length > 0) incrementListeningRetries();
         for (let wordHeard of wordsHeard.split(" ")) {
-          console.log(`WORD_MATCH: word="${wordHeard}"`);
-          // if (state.listen_flush) {
-          //   resetListeningRetries();
-          //   setListeningMessage(`Flushing transcript`);
-          //   console.log(`listen_flush=${state.listen_flush}`);
-          //   // escape to prevent further processing that may match words in
-          //   // next sentence
-          //   // break;
-          // } else
-          if (expecting.toLowerCase() === wordHeard.toLowerCase()) {
+          wordHeard = wordHeard.toLowerCase();
+          if (expecting === wordHeard) {
             setToNextTerminalState();
-            setListeningMessage(`Matched "${expecting.toLowerCase()}"`);
-          } else if (expectingAlt.toLowerCase() === wordHeard.toLowerCase()) {
+            setListeningMessage(`Matched "${expecting}"`);
+          } else if (expectingAlt === wordHeard) {
             setToNextTerminalState();
-            setListeningMessage(`Matched "${expectingAlt.toLowerCase()}"`);
+            setListeningMessage(`Matched "${expectingAlt}"`);
           } else if (
             expectingAlt.length > 0 &&
-            patternMatch(wordHeard.toLowerCase(), expectingAlt)
+            patternMatch(wordHeard, expectingAlt)
           ) {
             setToNextTerminalState();
-            setListeningMessage(
-              `Matched pattern "${expectingAlt.toLowerCase()}"`
-            );
+            setListeningMessage(`Matched pattern "${expectingAlt}"`);
           } else {
-            console.log(
-              setListeningMessage(
-                `Heard "${wordsHeard}"; Expecting "${expecting}",  "${expectingAlt}". Retries: ${state.listen_retries}.`
-              )
+            // console.log(
+            setListeningMessage(
+              `Comparing "${wordHeard}"" within ""${wordsHeard}"; Expecting "${expecting}",  "${expectingAlt}". Retries: ${state.listen_retries}.`
             );
           }
         }
-        // state.listen_retriesExceeded =
-        //   state.listen_retries_max > 0 &&
-        //   state.listen_retries >= state.listen_retries_max;
-        // if (state.listen_retriesExceeded) {
-        //   let message = `WORD_MATCH: Exceeded retries for "${expecting}"`;
-        //   console.log(message);
-        //   state.statusBar_message2 = message;
-        // }
       }
       return state;
     case WORD_NEXT:
@@ -945,13 +922,12 @@ export const rootReducer = (
     case RECITE_TOGGLE:
       state.recite_requested = !state.recite_requested;
       return state;
-
-    // case RECITE_WORD:
-    //   state.recite_word_requested = true;
-    //   return state;
-    // case RECITED_WORD:
-    //   state.recite_word_requested = false;
-    //   return state;
+    case RECITE_WORD:
+      state.recite_word_requested = true;
+      return state;
+    case RECITED_WORD:
+      state.recite_word_requested = false;
+      return state;
     case SETTINGS_TOGGLE:
       state.settings_toggle = !state.settings_toggle;
       if (state.settings_toggle) state.listen_active = false;
diff --git a/reading_fe_app/src/settingsContext.ts b/reading_fe_app/src/settingsContext.ts
index b2ad642..73c3566 100644
--- a/reading_fe_app/src/settingsContext.ts
+++ b/reading_fe_app/src/settingsContext.ts
@@ -15,12 +15,6 @@
  *
  **/
 import React from "react";
-import { useState } from "react";
-// import { ISpeechSettings } from "./reactcomp_speech";
-// import //  CListenSettings,
-//  IListenSettings,
-//ListenSettingsInitializer
-// "./reactcomp_listen";
 
 export enum RecitationMode {
   wordOnly = "word only",
